{"ast":null,"code":"'use strict';\n/**\n * Class representing an event.\n *\n * @private\n */\n\nvar _possibleConstructorReturn = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar Event =\n/**\n * Create a new `Event`.\n *\n * @param {String} type The name of the event\n * @param {Object} target A reference to the target to which the event was dispatched\n */\nfunction Event(type, target) {\n  _classCallCheck(this, Event);\n\n  this.target = target;\n  this.type = type;\n};\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */\n\n\nvar MessageEvent =\n/*#__PURE__*/\nfunction (_Event) {\n  _inherits(MessageEvent, _Event);\n\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  function MessageEvent(data, target) {\n    var _this;\n\n    _classCallCheck(this, MessageEvent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MessageEvent).call(this, 'message', target));\n    _this.data = data;\n    return _this;\n  }\n\n  return MessageEvent;\n}(Event);\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */\n\n\nvar CloseEvent =\n/*#__PURE__*/\nfunction (_Event2) {\n  _inherits(CloseEvent, _Event2);\n\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being closed\n   * @param {String} reason A human-readable string explaining why the connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  function CloseEvent(code, reason, target) {\n    var _this2;\n\n    _classCallCheck(this, CloseEvent);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(CloseEvent).call(this, 'close', target));\n    _this2.wasClean = target._closeFrameReceived && target._closeFrameSent;\n    _this2.reason = reason;\n    _this2.code = code;\n    return _this2;\n  }\n\n  return CloseEvent;\n}(Event);\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */\n\n\nvar OpenEvent =\n/*#__PURE__*/\nfunction (_Event3) {\n  _inherits(OpenEvent, _Event3);\n\n  /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  function OpenEvent(target) {\n    _classCallCheck(this, OpenEvent);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(OpenEvent).call(this, 'open', target));\n  }\n\n  return OpenEvent;\n}(Event);\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\n\n\nvar EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} method A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @public\n   */\n  addEventListener: function addEventListener(method, listener) {\n    if (typeof listener !== 'function') return;\n\n    function onMessage(data) {\n      listener.call(this, new MessageEvent(data, this));\n    }\n\n    function onClose(code, message) {\n      listener.call(this, new CloseEvent(code, message, this));\n    }\n\n    function onError(event) {\n      event.type = 'error';\n      event.target = this;\n      listener.call(this, event);\n    }\n\n    function onOpen() {\n      listener.call(this, new OpenEvent(this));\n    }\n\n    if (method === 'message') {\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} method A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */\n  removeEventListener: function removeEventListener(method, listener) {\n    var listeners = this.listeners(method);\n\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\n        this.removeListener(method, listeners[i]);\n      }\n    }\n  }\n};\nmodule.exports = EventTarget;","map":null,"metadata":{},"sourceType":"script"}