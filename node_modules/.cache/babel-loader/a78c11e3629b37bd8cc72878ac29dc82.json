{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/createClass\");\n\nvar safeBuffer = require('safe-buffer');\n\nvar PerMessageDeflate = require('./PerMessageDeflate');\n\nvar isValidUTF8 = require('./Validation');\n\nvar bufferUtil = require('./BufferUtil');\n\nvar ErrorCodes = require('./ErrorCodes');\n\nvar constants = require('./Constants');\n\nvar Buffer = safeBuffer.Buffer;\nvar GET_INFO = 0;\nvar GET_PAYLOAD_LENGTH_16 = 1;\nvar GET_PAYLOAD_LENGTH_64 = 2;\nvar GET_MASK = 3;\nvar GET_DATA = 4;\nvar INFLATING = 5;\n/**\n * HyBi Receiver implementation.\n */\n\nvar Receiver =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   * @param {String} binaryType The type for binary data\n   */\n  function Receiver(extensions, maxPayload, binaryType) {\n    _classCallCheck(this, Receiver);\n\n    this._binaryType = binaryType || constants.BINARY_TYPES[0];\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._mask = null;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._cleanupCallback = null;\n    this._hadError = false;\n    this._dead = false;\n    this._loop = false;\n    this.onmessage = null;\n    this.onclose = null;\n    this.onerror = null;\n    this.onping = null;\n    this.onpong = null;\n    this._state = GET_INFO;\n  }\n  /**\n   * Consumes bytes from the available buffered data.\n   *\n   * @param {Number} bytes The number of bytes to consume\n   * @return {Buffer} Consumed bytes\n   * @private\n   */\n\n\n  _createClass(Receiver, [{\n    key: \"readBuffer\",\n    value: function readBuffer(bytes) {\n      var offset = 0;\n      var dst;\n      var l;\n      this._bufferedBytes -= bytes;\n      if (bytes === this._buffers[0].length) return this._buffers.shift();\n\n      if (bytes < this._buffers[0].length) {\n        dst = this._buffers[0].slice(0, bytes);\n        this._buffers[0] = this._buffers[0].slice(bytes);\n        return dst;\n      }\n\n      dst = Buffer.allocUnsafe(bytes);\n\n      while (bytes > 0) {\n        l = this._buffers[0].length;\n\n        if (bytes >= l) {\n          this._buffers[0].copy(dst, offset);\n\n          offset += l;\n\n          this._buffers.shift();\n        } else {\n          this._buffers[0].copy(dst, offset, 0, bytes);\n\n          this._buffers[0] = this._buffers[0].slice(bytes);\n        }\n\n        bytes -= l;\n      }\n\n      return dst;\n    }\n    /**\n     * Checks if the number of buffered bytes is bigger or equal than `n` and\n     * calls `cleanup` if necessary.\n     *\n     * @param {Number} n The number of bytes to check against\n     * @return {Boolean} `true` if `bufferedBytes >= n`, else `false`\n     * @private\n     */\n\n  }, {\n    key: \"hasBufferedBytes\",\n    value: function hasBufferedBytes(n) {\n      if (this._bufferedBytes >= n) return true;\n      this._loop = false;\n      if (this._dead) this.cleanup(this._cleanupCallback);\n      return false;\n    }\n    /**\n     * Adds new data to the parser.\n     *\n     * @public\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(data) {\n      if (this._dead) return;\n      this._bufferedBytes += data.length;\n\n      this._buffers.push(data);\n\n      this.startLoop();\n    }\n    /**\n     * Starts the parsing loop.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"startLoop\",\n    value: function startLoop() {\n      this._loop = true;\n\n      while (this._loop) {\n        switch (this._state) {\n          case GET_INFO:\n            this.getInfo();\n            break;\n\n          case GET_PAYLOAD_LENGTH_16:\n            this.getPayloadLength16();\n            break;\n\n          case GET_PAYLOAD_LENGTH_64:\n            this.getPayloadLength64();\n            break;\n\n          case GET_MASK:\n            this.getMask();\n            break;\n\n          case GET_DATA:\n            this.getData();\n            break;\n\n          default:\n            // `INFLATING`\n            this._loop = false;\n        }\n      }\n    }\n    /**\n     * Reads the first two bytes of a frame.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"getInfo\",\n    value: function getInfo() {\n      if (!this.hasBufferedBytes(2)) return;\n      var buf = this.readBuffer(2);\n\n      if ((buf[0] & 0x30) !== 0x00) {\n        this.error(new Error('RSV2 and RSV3 must be clear'), 1002);\n        return;\n      }\n\n      var compressed = (buf[0] & 0x40) === 0x40;\n\n      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n\n      this._fin = (buf[0] & 0x80) === 0x80;\n      this._opcode = buf[0] & 0x0f;\n      this._payloadLength = buf[1] & 0x7f;\n\n      if (this._opcode === 0x00) {\n        if (compressed) {\n          this.error(new Error('RSV1 must be clear'), 1002);\n          return;\n        }\n\n        if (!this._fragmented) {\n          this.error(new Error(\"invalid opcode: \".concat(this._opcode)), 1002);\n          return;\n        } else {\n          this._opcode = this._fragmented;\n        }\n      } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n        if (this._fragmented) {\n          this.error(new Error(\"invalid opcode: \".concat(this._opcode)), 1002);\n          return;\n        }\n\n        this._compressed = compressed;\n      } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n        if (!this._fin) {\n          this.error(new Error('FIN must be set'), 1002);\n          return;\n        }\n\n        if (compressed) {\n          this.error(new Error('RSV1 must be clear'), 1002);\n          return;\n        }\n\n        if (this._payloadLength > 0x7d) {\n          this.error(new Error('invalid payload length'), 1002);\n          return;\n        }\n      } else {\n        this.error(new Error(\"invalid opcode: \".concat(this._opcode)), 1002);\n        return;\n      }\n\n      if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n      this._masked = (buf[1] & 0x80) === 0x80;\n      if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else this.haveLength();\n    }\n    /**\n     * Gets extended payload length (7+16).\n     *\n     * @private\n     */\n\n  }, {\n    key: \"getPayloadLength16\",\n    value: function getPayloadLength16() {\n      if (!this.hasBufferedBytes(2)) return;\n      this._payloadLength = this.readBuffer(2).readUInt16BE(0, true);\n      this.haveLength();\n    }\n    /**\n     * Gets extended payload length (7+64).\n     *\n     * @private\n     */\n\n  }, {\n    key: \"getPayloadLength64\",\n    value: function getPayloadLength64() {\n      if (!this.hasBufferedBytes(8)) return;\n      var buf = this.readBuffer(8);\n      var num = buf.readUInt32BE(0, true); //\n      // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n      // if payload length is greater than this number.\n      //\n\n      if (num > Math.pow(2, 53 - 32) - 1) {\n        this.error(new Error('max payload size exceeded'), 1009);\n        return;\n      }\n\n      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4, true);\n      this.haveLength();\n    }\n    /**\n     * Payload length has been read.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"haveLength\",\n    value: function haveLength() {\n      if (this._opcode < 0x08 && this.maxPayloadExceeded(this._payloadLength)) {\n        return;\n      }\n\n      if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n    }\n    /**\n     * Reads mask bytes.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"getMask\",\n    value: function getMask() {\n      if (!this.hasBufferedBytes(4)) return;\n      this._mask = this.readBuffer(4);\n      this._state = GET_DATA;\n    }\n    /**\n     * Reads data bytes.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var data = constants.EMPTY_BUFFER;\n\n      if (this._payloadLength) {\n        if (!this.hasBufferedBytes(this._payloadLength)) return;\n        data = this.readBuffer(this._payloadLength);\n        if (this._masked) bufferUtil.unmask(data, this._mask);\n      }\n\n      if (this._opcode > 0x07) {\n        this.controlMessage(data);\n      } else if (this._compressed) {\n        this._state = INFLATING;\n        this.decompress(data);\n      } else if (this.pushFragment(data)) {\n        this.dataMessage();\n      }\n    }\n    /**\n     * Decompresses data.\n     *\n     * @param {Buffer} data Compressed data\n     * @private\n     */\n\n  }, {\n    key: \"decompress\",\n    value: function decompress(data) {\n      var _this = this;\n\n      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n      perMessageDeflate.decompress(data, this._fin, function (err, buf) {\n        if (err) {\n          _this.error(err, err.closeCode === 1009 ? 1009 : 1007);\n\n          return;\n        }\n\n        if (_this.pushFragment(buf)) _this.dataMessage();\n\n        _this.startLoop();\n      });\n    }\n    /**\n     * Handles a data message.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"dataMessage\",\n    value: function dataMessage() {\n      if (this._fin) {\n        var messageLength = this._messageLength;\n        var fragments = this._fragments;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragmented = 0;\n        this._fragments = [];\n\n        if (this._opcode === 2) {\n          var data;\n\n          if (this._binaryType === 'nodebuffer') {\n            data = toBuffer(fragments, messageLength);\n          } else if (this._binaryType === 'arraybuffer') {\n            data = toArrayBuffer(toBuffer(fragments, messageLength));\n          } else {\n            data = fragments;\n          }\n\n          this.onmessage(data);\n        } else {\n          var buf = toBuffer(fragments, messageLength);\n\n          if (!isValidUTF8(buf)) {\n            this.error(new Error('invalid utf8 sequence'), 1007);\n            return;\n          }\n\n          this.onmessage(buf.toString());\n        }\n      }\n\n      this._state = GET_INFO;\n    }\n    /**\n     * Handles a control message.\n     *\n     * @param {Buffer} data Data to handle\n     * @private\n     */\n\n  }, {\n    key: \"controlMessage\",\n    value: function controlMessage(data) {\n      if (this._opcode === 0x08) {\n        if (data.length === 0) {\n          this.onclose(1000, '');\n          this._loop = false;\n          this.cleanup(this._cleanupCallback);\n        } else if (data.length === 1) {\n          this.error(new Error('invalid payload length'), 1002);\n        } else {\n          var code = data.readUInt16BE(0, true);\n\n          if (!ErrorCodes.isValidErrorCode(code)) {\n            this.error(new Error(\"invalid status code: \".concat(code)), 1002);\n            return;\n          }\n\n          var buf = data.slice(2);\n\n          if (!isValidUTF8(buf)) {\n            this.error(new Error('invalid utf8 sequence'), 1007);\n            return;\n          }\n\n          this.onclose(code, buf.toString());\n          this._loop = false;\n          this.cleanup(this._cleanupCallback);\n        }\n\n        return;\n      }\n\n      if (this._opcode === 0x09) this.onping(data);else this.onpong(data);\n      this._state = GET_INFO;\n    }\n    /**\n     * Handles an error.\n     *\n     * @param {Error} err The error\n     * @param {Number} code Close code\n     * @private\n     */\n\n  }, {\n    key: \"error\",\n    value: function error(err, code) {\n      this.onerror(err, code);\n      this._hadError = true;\n      this._loop = false;\n      this.cleanup(this._cleanupCallback);\n    }\n    /**\n     * Checks payload size, disconnects socket when it exceeds `maxPayload`.\n     *\n     * @param {Number} length Payload length\n     * @private\n     */\n\n  }, {\n    key: \"maxPayloadExceeded\",\n    value: function maxPayloadExceeded(length) {\n      if (length === 0 || this._maxPayload < 1) return false;\n      var fullLength = this._totalPayloadLength + length;\n\n      if (fullLength <= this._maxPayload) {\n        this._totalPayloadLength = fullLength;\n        return false;\n      }\n\n      this.error(new Error('max payload size exceeded'), 1009);\n      return true;\n    }\n    /**\n     * Appends a fragment in the fragments array after checking that the sum of\n     * fragment lengths does not exceed `maxPayload`.\n     *\n     * @param {Buffer} fragment The fragment to add\n     * @return {Boolean} `true` if `maxPayload` is not exceeded, else `false`\n     * @private\n     */\n\n  }, {\n    key: \"pushFragment\",\n    value: function pushFragment(fragment) {\n      if (fragment.length === 0) return true;\n      var totalLength = this._messageLength + fragment.length;\n\n      if (this._maxPayload < 1 || totalLength <= this._maxPayload) {\n        this._messageLength = totalLength;\n\n        this._fragments.push(fragment);\n\n        return true;\n      }\n\n      this.error(new Error('max payload size exceeded'), 1009);\n      return false;\n    }\n    /**\n     * Releases resources used by the receiver.\n     *\n     * @param {Function} cb Callback\n     * @public\n     */\n\n  }, {\n    key: \"cleanup\",\n    value: function cleanup(cb) {\n      this._dead = true;\n\n      if (!this._hadError && (this._loop || this._state === INFLATING)) {\n        this._cleanupCallback = cb;\n      } else {\n        this._extensions = null;\n        this._fragments = null;\n        this._buffers = null;\n        this._mask = null;\n        this._cleanupCallback = null;\n        this.onmessage = null;\n        this.onclose = null;\n        this.onerror = null;\n        this.onping = null;\n        this.onpong = null;\n        if (cb) cb();\n      }\n    }\n  }]);\n\n  return Receiver;\n}();\n\nmodule.exports = Receiver;\n/**\n * Makes a buffer from a list of fragments.\n *\n * @param {Buffer[]} fragments The list of fragments composing the message\n * @param {Number} messageLength The length of the message\n * @return {Buffer}\n * @private\n */\n\nfunction toBuffer(fragments, messageLength) {\n  if (fragments.length === 1) return fragments[0];\n  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\n  return constants.EMPTY_BUFFER;\n}\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n */\n\n\nfunction toArrayBuffer(buf) {\n  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}","map":null,"metadata":{},"sourceType":"script"}