{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/createClass\");\n\nvar safeBuffer = require('safe-buffer');\n\nvar crypto = require('crypto');\n\nvar PerMessageDeflate = require('./PerMessageDeflate');\n\nvar bufferUtil = require('./BufferUtil');\n\nvar ErrorCodes = require('./ErrorCodes');\n\nvar constants = require('./Constants');\n\nvar Buffer = safeBuffer.Buffer;\n/**\n * HyBi Sender implementation.\n */\n\nvar Sender =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  function Sender(socket, extensions) {\n    _classCallCheck(this, Sender);\n\n    this._extensions = extensions || {};\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n\n\n  _createClass(Sender, [{\n    key: \"close\",\n\n    /**\n     * Sends a close message to the other peer.\n     *\n     * @param {(Number|undefined)} code The status code component of the body\n     * @param {String} data The message component of the body\n     * @param {Boolean} mask Specifies whether or not to mask the message\n     * @param {Function} cb Callback\n     * @public\n     */\n    value: function close(code, data, mask, cb) {\n      var buf;\n\n      if (code === undefined) {\n        code = 1000;\n      } else if (typeof code !== 'number' || !ErrorCodes.isValidErrorCode(code)) {\n        throw new Error('first argument must be a valid error code number');\n      }\n\n      if (data === undefined || data === '') {\n        if (code === 1000) {\n          buf = constants.EMPTY_BUFFER;\n        } else {\n          buf = Buffer.allocUnsafe(2);\n          buf.writeUInt16BE(code, 0, true);\n        }\n      } else {\n        buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n        buf.writeUInt16BE(code, 0, true);\n        buf.write(data, 2);\n      }\n\n      if (this._deflating) {\n        this.enqueue([this.doClose, buf, mask, cb]);\n      } else {\n        this.doClose(buf, mask, cb);\n      }\n    }\n    /**\n     * Frames and sends a close message.\n     *\n     * @param {Buffer} data The message to send\n     * @param {Boolean} mask Specifies whether or not to mask `data`\n     * @param {Function} cb Callback\n     * @private\n     */\n\n  }, {\n    key: \"doClose\",\n    value: function doClose(data, mask, cb) {\n      this.sendFrame(Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x08,\n        mask: mask,\n        readOnly: false\n      }), cb);\n    }\n    /**\n     * Sends a ping message to the other peer.\n     *\n     * @param {*} data The message to send\n     * @param {Boolean} mask Specifies whether or not to mask `data`\n     * @public\n     */\n\n  }, {\n    key: \"ping\",\n    value: function ping(data, mask) {\n      var readOnly = true;\n\n      if (!Buffer.isBuffer(data)) {\n        if (data instanceof ArrayBuffer) {\n          data = Buffer.from(data);\n        } else if (ArrayBuffer.isView(data)) {\n          data = viewToBuffer(data);\n        } else {\n          data = Buffer.from(data);\n          readOnly = false;\n        }\n      }\n\n      if (this._deflating) {\n        this.enqueue([this.doPing, data, mask, readOnly]);\n      } else {\n        this.doPing(data, mask, readOnly);\n      }\n    }\n    /**\n     * Frames and sends a ping message.\n     *\n     * @param {*} data The message to send\n     * @param {Boolean} mask Specifies whether or not to mask `data`\n     * @param {Boolean} readOnly Specifies whether `data` can be modified\n     * @private\n     */\n\n  }, {\n    key: \"doPing\",\n    value: function doPing(data, mask, readOnly) {\n      this.sendFrame(Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x09,\n        mask: mask,\n        readOnly: readOnly\n      }));\n    }\n    /**\n     * Sends a pong message to the other peer.\n     *\n     * @param {*} data The message to send\n     * @param {Boolean} mask Specifies whether or not to mask `data`\n     * @public\n     */\n\n  }, {\n    key: \"pong\",\n    value: function pong(data, mask) {\n      var readOnly = true;\n\n      if (!Buffer.isBuffer(data)) {\n        if (data instanceof ArrayBuffer) {\n          data = Buffer.from(data);\n        } else if (ArrayBuffer.isView(data)) {\n          data = viewToBuffer(data);\n        } else {\n          data = Buffer.from(data);\n          readOnly = false;\n        }\n      }\n\n      if (this._deflating) {\n        this.enqueue([this.doPong, data, mask, readOnly]);\n      } else {\n        this.doPong(data, mask, readOnly);\n      }\n    }\n    /**\n     * Frames and sends a pong message.\n     *\n     * @param {*} data The message to send\n     * @param {Boolean} mask Specifies whether or not to mask `data`\n     * @param {Boolean} readOnly Specifies whether `data` can be modified\n     * @private\n     */\n\n  }, {\n    key: \"doPong\",\n    value: function doPong(data, mask, readOnly) {\n      this.sendFrame(Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x0a,\n        mask: mask,\n        readOnly: readOnly\n      }));\n    }\n    /**\n     * Sends a data message to the other peer.\n     *\n     * @param {*} data The message to send\n     * @param {Object} options Options object\n     * @param {Boolean} options.compress Specifies whether or not to compress `data`\n     * @param {Boolean} options.binary Specifies whether `data` is binary or text\n     * @param {Boolean} options.fin Specifies whether the fragment is the last one\n     * @param {Boolean} options.mask Specifies whether or not to mask `data`\n     * @param {Function} cb Callback\n     * @public\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(data, options, cb) {\n      var opcode = options.binary ? 2 : 1;\n      var rsv1 = options.compress;\n      var readOnly = true;\n\n      if (!Buffer.isBuffer(data)) {\n        if (data instanceof ArrayBuffer) {\n          data = Buffer.from(data);\n        } else if (ArrayBuffer.isView(data)) {\n          data = viewToBuffer(data);\n        } else {\n          data = Buffer.from(data);\n          readOnly = false;\n        }\n      }\n\n      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n      if (this._firstFragment) {\n        this._firstFragment = false;\n\n        if (rsv1 && perMessageDeflate) {\n          rsv1 = data.length >= perMessageDeflate._threshold;\n        }\n\n        this._compress = rsv1;\n      } else {\n        rsv1 = false;\n        opcode = 0;\n      }\n\n      if (options.fin) this._firstFragment = true;\n\n      if (perMessageDeflate) {\n        var opts = {\n          fin: options.fin,\n          rsv1: rsv1,\n          opcode: opcode,\n          mask: options.mask,\n          readOnly: readOnly\n        };\n\n        if (this._deflating) {\n          this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n        } else {\n          this.dispatch(data, this._compress, opts, cb);\n        }\n      } else {\n        this.sendFrame(Sender.frame(data, {\n          fin: options.fin,\n          rsv1: false,\n          opcode: opcode,\n          mask: options.mask,\n          readOnly: readOnly\n        }), cb);\n      }\n    }\n    /**\n     * Dispatches a data message.\n     *\n     * @param {Buffer} data The message to send\n     * @param {Boolean} compress Specifies whether or not to compress `data`\n     * @param {Object} options Options object\n     * @param {Number} options.opcode The opcode\n     * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n     * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n     * @param {Boolean} options.mask Specifies whether or not to mask `data`\n     * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n     * @param {Function} cb Callback\n     * @private\n     */\n\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(data, compress, options, cb) {\n      var _this = this;\n\n      if (!compress) {\n        this.sendFrame(Sender.frame(data, options), cb);\n        return;\n      }\n\n      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n      this._deflating = true;\n      perMessageDeflate.compress(data, options.fin, function (_, buf) {\n        options.readOnly = false;\n\n        _this.sendFrame(Sender.frame(buf, options), cb);\n\n        _this._deflating = false;\n\n        _this.dequeue();\n      });\n    }\n    /**\n     * Executes queued send operations.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      while (!this._deflating && this._queue.length) {\n        var params = this._queue.shift();\n\n        this._bufferedBytes -= params[1].length;\n        params[0].apply(this, params.slice(1));\n      }\n    }\n    /**\n     * Enqueues a send operation.\n     *\n     * @param {Array} params Send operation parameters.\n     * @private\n     */\n\n  }, {\n    key: \"enqueue\",\n    value: function enqueue(params) {\n      this._bufferedBytes += params[1].length;\n\n      this._queue.push(params);\n    }\n    /**\n     * Sends a frame.\n     *\n     * @param {Buffer[]} list The frame to send\n     * @param {Function} cb Callback\n     * @private\n     */\n\n  }, {\n    key: \"sendFrame\",\n    value: function sendFrame(list, cb) {\n      if (list.length === 2) {\n        this._socket.write(list[0]);\n\n        this._socket.write(list[1], cb);\n      } else {\n        this._socket.write(list[0], cb);\n      }\n    }\n  }], [{\n    key: \"frame\",\n    value: function frame(data, options) {\n      var merge = data.length < 1024 || options.mask && options.readOnly;\n      var offset = options.mask ? 6 : 2;\n      var payloadLength = data.length;\n\n      if (data.length >= 65536) {\n        offset += 8;\n        payloadLength = 127;\n      } else if (data.length > 125) {\n        offset += 2;\n        payloadLength = 126;\n      }\n\n      var target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n      target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n      if (options.rsv1) target[0] |= 0x40;\n\n      if (payloadLength === 126) {\n        target.writeUInt16BE(data.length, 2, true);\n      } else if (payloadLength === 127) {\n        target.writeUInt32BE(0, 2, true);\n        target.writeUInt32BE(data.length, 6, true);\n      }\n\n      if (!options.mask) {\n        target[1] = payloadLength;\n\n        if (merge) {\n          data.copy(target, offset);\n          return [target];\n        }\n\n        return [target, data];\n      }\n\n      var mask = crypto.randomBytes(4);\n      target[1] = payloadLength | 0x80;\n      target[offset - 4] = mask[0];\n      target[offset - 3] = mask[1];\n      target[offset - 2] = mask[2];\n      target[offset - 1] = mask[3];\n\n      if (merge) {\n        bufferUtil.mask(data, mask, target, offset, data.length);\n        return [target];\n      }\n\n      bufferUtil.mask(data, mask, data, 0, data.length);\n      return [target, data];\n    }\n  }]);\n\n  return Sender;\n}();\n\nmodule.exports = Sender;\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\n\nfunction viewToBuffer(view) {\n  var buf = Buffer.from(view.buffer);\n\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n\n  return buf;\n}","map":null,"metadata":{},"sourceType":"script"}