{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n'use strict';\n\nvar _defineProperty = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar EventEmitter = require('events');\n\nvar crypto = require('crypto');\n\nvar Ultron = require('ultron');\n\nvar https = require('https');\n\nvar http = require('http');\n\nvar url = require('url');\n\nvar PerMessageDeflate = require('./PerMessageDeflate');\n\nvar EventTarget = require('./EventTarget');\n\nvar Extensions = require('./Extensions');\n\nvar constants = require('./Constants');\n\nvar Receiver = require('./Receiver');\n\nvar Sender = require('./Sender');\n\nvar protocolVersions = [8, 13];\nvar closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\n\nvar WebSocket =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(WebSocket, _EventEmitter);\n\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {String} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  function WebSocket(address, protocols, options) {\n    var _this;\n\n    _classCallCheck(this, WebSocket);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebSocket).call(this));\n\n    if (!protocols) {\n      protocols = [];\n    } else if (typeof protocols === 'string') {\n      protocols = [protocols];\n    } else if (!Array.isArray(protocols)) {\n      options = protocols;\n      protocols = [];\n    }\n\n    _this.readyState = WebSocket.CONNECTING;\n    _this.bytesReceived = 0;\n    _this.extensions = {};\n    _this.protocol = '';\n    _this._binaryType = constants.BINARY_TYPES[0];\n    _this._finalize = _this.finalize.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._closeFrameReceived = false;\n    _this._closeFrameSent = false;\n    _this._closeMessage = '';\n    _this._closeTimer = null;\n    _this._finalized = false;\n    _this._closeCode = 1006;\n    _this._receiver = null;\n    _this._sender = null;\n    _this._socket = null;\n    _this._ultron = null;\n\n    if (Array.isArray(address)) {\n      initAsServerClient.call(_assertThisInitialized(_assertThisInitialized(_this)), address[0], address[1], options);\n    } else {\n      initAsClient.call(_assertThisInitialized(_assertThisInitialized(_this)), address, protocols, options);\n    }\n\n    return _this;\n  }\n\n  _createClass(WebSocket, [{\n    key: \"setSocket\",\n\n    /**\n     * Set up the socket and the internal resources.\n     *\n     * @param {net.Socket} socket The network socket between the server and client\n     * @param {Buffer} head The first packet of the upgraded stream\n     * @private\n     */\n    value: function setSocket(socket, head) {\n      var _this2 = this;\n\n      socket.setTimeout(0);\n      socket.setNoDelay();\n      this._receiver = new Receiver(this.extensions, this._maxPayload, this.binaryType);\n      this._sender = new Sender(socket, this.extensions);\n      this._ultron = new Ultron(socket);\n      this._socket = socket;\n\n      this._ultron.on('close', this._finalize);\n\n      this._ultron.on('error', this._finalize);\n\n      this._ultron.on('end', this._finalize);\n\n      if (head.length > 0) socket.unshift(head);\n\n      this._ultron.on('data', function (data) {\n        _this2.bytesReceived += data.length;\n\n        _this2._receiver.add(data);\n      });\n\n      this._receiver.onmessage = function (data) {\n        return _this2.emit('message', data);\n      };\n\n      this._receiver.onping = function (data) {\n        _this2.pong(data, !_this2._isServer, true);\n\n        _this2.emit('ping', data);\n      };\n\n      this._receiver.onpong = function (data) {\n        return _this2.emit('pong', data);\n      };\n\n      this._receiver.onclose = function (code, reason) {\n        _this2._closeFrameReceived = true;\n        _this2._closeMessage = reason;\n        _this2._closeCode = code;\n        if (!_this2._finalized) _this2.close(code, reason);\n      };\n\n      this._receiver.onerror = function (error, code) {\n        _this2._closeMessage = '';\n        _this2._closeCode = code; //\n        // Ensure that the error is emitted even if `WebSocket#finalize()` has\n        // already been called.\n        //\n\n        _this2.readyState = WebSocket.CLOSING;\n\n        _this2.emit('error', error);\n\n        _this2.finalize(true);\n      };\n\n      this.readyState = WebSocket.OPEN;\n      this.emit('open');\n    }\n    /**\n     * Clean up and release internal resources.\n     *\n     * @param {(Boolean|Error)} error Indicates whether or not an error occurred\n     * @private\n     */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize(error) {\n      var _this3 = this;\n\n      if (this._finalized) return;\n      this.readyState = WebSocket.CLOSING;\n      this._finalized = true;\n      if (typeof error === 'object') this.emit('error', error);\n      if (!this._socket) return this.emitClose();\n      clearTimeout(this._closeTimer);\n      this._closeTimer = null;\n\n      this._ultron.destroy();\n\n      this._ultron = null;\n\n      this._socket.on('error', constants.NOOP);\n\n      if (!error) this._socket.end();else this._socket.destroy();\n      this._socket = null;\n      this._sender = null;\n\n      this._receiver.cleanup(function () {\n        return _this3.emitClose();\n      });\n\n      this._receiver = null;\n    }\n    /**\n     * Emit the `close` event.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"emitClose\",\n    value: function emitClose() {\n      this.readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n\n      if (this.extensions[PerMessageDeflate.extensionName]) {\n        this.extensions[PerMessageDeflate.extensionName].cleanup();\n      }\n\n      this.extensions = null;\n      this.removeAllListeners();\n    }\n    /**\n     * Pause the socket stream.\n     *\n     * @public\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n      this._socket.pause();\n    }\n    /**\n     * Resume the socket stream\n     *\n     * @public\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n      this._socket.resume();\n    }\n    /**\n     * Start a closing handshake.\n     *\n     *            +----------+     +-----------+   +----------+\n     *     + - - -|ws.close()|---->|close frame|-->|ws.close()|- - - -\n     *            +----------+     +-----------+   +----------+       |\n     *     |      +----------+     +-----------+         |\n     *            |ws.close()|<----|close frame|<--------+            |\n     *            +----------+     +-----------+         |\n     *  CLOSING         |              +---+             |         CLOSING\n     *                  |          +---|fin|<------------+\n     *     |            |          |   +---+                          |\n     *                  |          |   +---+      +-------------+\n     *     |            +----------+-->|fin|----->|ws.finalize()| - - +\n     *                             |   +---+      +-------------+\n     *     |     +-------------+   |\n     *      - - -|ws.finalize()|<--+\n     *           +-------------+\n     *\n     * @param {Number} code Status code explaining why the connection is closing\n     * @param {String} data A string explaining why the connection is closing\n     * @public\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(code, data) {\n      var _this4 = this;\n\n      if (this.readyState === WebSocket.CLOSED) return;\n\n      if (this.readyState === WebSocket.CONNECTING) {\n        this._req.abort();\n\n        this.finalize(new Error('closed before the connection is established'));\n        return;\n      }\n\n      if (this.readyState === WebSocket.CLOSING) {\n        if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n        return;\n      }\n\n      this.readyState = WebSocket.CLOSING;\n\n      this._sender.close(code, data, !this._isServer, function (err) {\n        //\n        // This error is handled by the `'error'` listener on the socket. We only\n        // want to know if the close frame has been sent here.\n        //\n        if (err) return;\n        _this4._closeFrameSent = true;\n\n        if (!_this4._finalized) {\n          if (_this4._closeFrameReceived) _this4._socket.end(); //\n          // Ensure that the connection is cleaned up even when the closing\n          // handshake fails.\n          //\n\n          _this4._closeTimer = setTimeout(_this4._finalize, closeTimeout, true);\n        }\n      });\n    }\n    /**\n     * Send a ping message.\n     *\n     * @param {*} data The message to send\n     * @param {Boolean} mask Indicates whether or not to mask `data`\n     * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n     * @public\n     */\n\n  }, {\n    key: \"ping\",\n    value: function ping(data, mask, failSilently) {\n      if (this.readyState !== WebSocket.OPEN) {\n        if (failSilently) return;\n        throw new Error('not opened');\n      }\n\n      if (typeof data === 'number') data = data.toString();\n      if (mask === undefined) mask = !this._isServer;\n\n      this._sender.ping(data || constants.EMPTY_BUFFER, mask);\n    }\n    /**\n     * Send a pong message.\n     *\n     * @param {*} data The message to send\n     * @param {Boolean} mask Indicates whether or not to mask `data`\n     * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n     * @public\n     */\n\n  }, {\n    key: \"pong\",\n    value: function pong(data, mask, failSilently) {\n      if (this.readyState !== WebSocket.OPEN) {\n        if (failSilently) return;\n        throw new Error('not opened');\n      }\n\n      if (typeof data === 'number') data = data.toString();\n      if (mask === undefined) mask = !this._isServer;\n\n      this._sender.pong(data || constants.EMPTY_BUFFER, mask);\n    }\n    /**\n     * Send a data message.\n     *\n     * @param {*} data The message to send\n     * @param {Object} options Options object\n     * @param {Boolean} options.compress Specifies whether or not to compress `data`\n     * @param {Boolean} options.binary Specifies whether `data` is binary or text\n     * @param {Boolean} options.fin Specifies whether the fragment is the last one\n     * @param {Boolean} options.mask Specifies whether or not to mask `data`\n     * @param {Function} cb Callback which is executed when data is written out\n     * @public\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(data, options, cb) {\n      if (typeof options === 'function') {\n        cb = options;\n        options = {};\n      }\n\n      if (this.readyState !== WebSocket.OPEN) {\n        if (cb) cb(new Error('not opened'));else throw new Error('not opened');\n        return;\n      }\n\n      if (typeof data === 'number') data = data.toString();\n      var opts = Object.assign({\n        binary: typeof data !== 'string',\n        mask: !this._isServer,\n        compress: true,\n        fin: true\n      }, options);\n\n      if (!this.extensions[PerMessageDeflate.extensionName]) {\n        opts.compress = false;\n      }\n\n      this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);\n    }\n    /**\n     * Forcibly close the connection.\n     *\n     * @public\n     */\n\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      if (this.readyState === WebSocket.CLOSED) return;\n\n      if (this.readyState === WebSocket.CONNECTING) {\n        this._req.abort();\n\n        this.finalize(new Error('closed before the connection is established'));\n        return;\n      }\n\n      this.finalize(true);\n    }\n  }, {\n    key: \"CONNECTING\",\n    get: function get() {\n      return WebSocket.CONNECTING;\n    }\n  }, {\n    key: \"CLOSING\",\n    get: function get() {\n      return WebSocket.CLOSING;\n    }\n  }, {\n    key: \"CLOSED\",\n    get: function get() {\n      return WebSocket.CLOSED;\n    }\n  }, {\n    key: \"OPEN\",\n    get: function get() {\n      return WebSocket.OPEN;\n    }\n    /**\n     * @type {Number}\n     */\n\n  }, {\n    key: \"bufferedAmount\",\n    get: function get() {\n      var amount = 0;\n\n      if (this._socket) {\n        amount = this._socket.bufferSize + this._sender._bufferedBytes;\n      }\n\n      return amount;\n    }\n    /**\n     * This deviates from the WHATWG interface since ws doesn't support the required\n     * default \"blob\" type (instead we define a custom \"nodebuffer\" type).\n     *\n     * @type {String}\n     */\n\n  }, {\n    key: \"binaryType\",\n    get: function get() {\n      return this._binaryType;\n    },\n    set: function set(type) {\n      if (constants.BINARY_TYPES.indexOf(type) < 0) return;\n      this._binaryType = type; //\n      // Allow to change `binaryType` on the fly.\n      //\n\n      if (this._receiver) this._receiver._binaryType = type;\n    }\n  }]);\n\n  return WebSocket;\n}(EventEmitter);\n\nWebSocket.CONNECTING = 0;\nWebSocket.OPEN = 1;\nWebSocket.CLOSING = 2;\nWebSocket.CLOSED = 3; //\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n\n['open', 'error', 'close', 'message'].forEach(function (method) {\n  Object.defineProperty(WebSocket.prototype, \"on\".concat(method), {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get: function get() {\n      var listeners = this.listeners(method);\n\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n    },\n\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set: function set(listener) {\n      var listeners = this.listeners(method);\n\n      for (var i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n\n      this.addEventListener(method, listener);\n    }\n  });\n});\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket server client.\n *\n * @param {http.IncomingMessage} req The request object\n * @param {net.Socket} socket The network socket between the server and client\n * @param {Buffer} head The first packet of the upgraded stream\n * @param {Object} options WebSocket attributes\n * @param {Number} options.protocolVersion The WebSocket protocol version\n * @param {Object} options.extensions The negotiated extensions\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {String} options.protocol The chosen subprotocol\n * @private\n */\n\nfunction initAsServerClient(socket, head, options) {\n  this.protocolVersion = options.protocolVersion;\n  this._maxPayload = options.maxPayload;\n  this.extensions = options.extensions;\n  this.protocol = options.protocol;\n  this._isServer = true;\n  this.setSocket(socket, head);\n}\n/**\n * Initialize a WebSocket client.\n *\n * @param {String} address The URL to which to connect\n * @param {String[]} protocols The list of subprotocols\n * @param {Object} options Connection options\n * @param {String} options.protocol Value of the `Sec-WebSocket-Protocol` header\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request\n * @param {String} options.localAddress Local interface to bind for network connections\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header\n * @param {Object} options.headers An object containing request headers\n * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header\n * @param {http.Agent} options.agent Use the specified Agent\n * @param {String} options.host Value of the `Host` header\n * @param {Number} options.family IP address family to use during hostname lookup (4 or 6).\n * @param {Function} options.checkServerIdentity A function to validate the server hostname\n * @param {Boolean} options.rejectUnauthorized Verify or not the server certificate\n * @param {String} options.passphrase The passphrase for the private key or pfx\n * @param {String} options.ciphers The ciphers to use or exclude\n * @param {String} options.ecdhCurve The curves for ECDH key agreement to use or exclude\n * @param {(String|String[]|Buffer|Buffer[])} options.cert The certificate key\n * @param {(String|String[]|Buffer|Buffer[])} options.key The private key\n * @param {(String|Buffer)} options.pfx The private key, certificate, and CA certs\n * @param {(String|String[]|Buffer|Buffer[])} options.ca Trusted certificates\n * @private\n */\n\n\nfunction initAsClient(address, protocols, options) {\n  var _this5 = this;\n\n  options = Object.assign({\n    protocolVersion: protocolVersions[1],\n    protocol: protocols.join(','),\n    perMessageDeflate: true,\n    handshakeTimeout: null,\n    localAddress: null,\n    headers: null,\n    family: null,\n    origin: null,\n    agent: null,\n    host: null,\n    //\n    // SSL options.\n    //\n    checkServerIdentity: null,\n    rejectUnauthorized: null,\n    passphrase: null,\n    ciphers: null,\n    ecdhCurve: null,\n    cert: null,\n    key: null,\n    pfx: null,\n    ca: null\n  }, options);\n\n  if (protocolVersions.indexOf(options.protocolVersion) === -1) {\n    throw new Error(\"unsupported protocol version: \".concat(options.protocolVersion, \" \") + \"(supported versions: \".concat(protocolVersions.join(', '), \")\"));\n  }\n\n  this.protocolVersion = options.protocolVersion;\n  this._isServer = false;\n  this.url = address;\n  var serverUrl = url.parse(address);\n  var isUnixSocket = serverUrl.protocol === 'ws+unix:';\n\n  if (!serverUrl.host && (!isUnixSocket || !serverUrl.path)) {\n    throw new Error('invalid url');\n  }\n\n  var isSecure = serverUrl.protocol === 'wss:' || serverUrl.protocol === 'https:';\n  var key = crypto.randomBytes(16).toString('base64');\n  var httpObj = isSecure ? https : http;\n  var perMessageDeflate;\n  var requestOptions = {\n    port: serverUrl.port || (isSecure ? 443 : 80),\n    host: serverUrl.hostname,\n    path: '/',\n    headers: {\n      'Sec-WebSocket-Version': options.protocolVersion,\n      'Sec-WebSocket-Key': key,\n      'Connection': 'Upgrade',\n      'Upgrade': 'websocket'\n    }\n  };\n  if (options.headers) Object.assign(requestOptions.headers, options.headers);\n\n  if (options.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(options.perMessageDeflate !== true ? options.perMessageDeflate : {}, false);\n    requestOptions.headers['Sec-WebSocket-Extensions'] = Extensions.format(_defineProperty({}, PerMessageDeflate.extensionName, perMessageDeflate.offer()));\n  }\n\n  if (options.protocol) {\n    requestOptions.headers['Sec-WebSocket-Protocol'] = options.protocol;\n  }\n\n  if (options.origin) {\n    if (options.protocolVersion < 13) {\n      requestOptions.headers['Sec-WebSocket-Origin'] = options.origin;\n    } else {\n      requestOptions.headers.Origin = options.origin;\n    }\n  }\n\n  if (options.host) requestOptions.headers.Host = options.host;\n  if (serverUrl.auth) requestOptions.auth = serverUrl.auth;\n  if (options.localAddress) requestOptions.localAddress = options.localAddress;\n  if (options.family) requestOptions.family = options.family;\n\n  if (isUnixSocket) {\n    var parts = serverUrl.path.split(':');\n    requestOptions.socketPath = parts[0];\n    requestOptions.path = parts[1];\n  } else if (serverUrl.path) {\n    //\n    // Make sure that path starts with `/`.\n    //\n    if (serverUrl.path.charAt(0) !== '/') {\n      requestOptions.path = \"/\".concat(serverUrl.path);\n    } else {\n      requestOptions.path = serverUrl.path;\n    }\n  }\n\n  var agent = options.agent; //\n  // A custom agent is required for these options.\n  //\n\n  if (options.rejectUnauthorized != null || options.checkServerIdentity || options.passphrase || options.ciphers || options.ecdhCurve || options.cert || options.key || options.pfx || options.ca) {\n    if (options.passphrase) requestOptions.passphrase = options.passphrase;\n    if (options.ciphers) requestOptions.ciphers = options.ciphers;\n    if (options.ecdhCurve) requestOptions.ecdhCurve = options.ecdhCurve;\n    if (options.cert) requestOptions.cert = options.cert;\n    if (options.key) requestOptions.key = options.key;\n    if (options.pfx) requestOptions.pfx = options.pfx;\n    if (options.ca) requestOptions.ca = options.ca;\n\n    if (options.checkServerIdentity) {\n      requestOptions.checkServerIdentity = options.checkServerIdentity;\n    }\n\n    if (options.rejectUnauthorized != null) {\n      requestOptions.rejectUnauthorized = options.rejectUnauthorized;\n    }\n\n    if (!agent) agent = new httpObj.Agent(requestOptions);\n  }\n\n  if (agent) requestOptions.agent = agent;\n  this._req = httpObj.get(requestOptions);\n\n  if (options.handshakeTimeout) {\n    this._req.setTimeout(options.handshakeTimeout, function () {\n      _this5._req.abort();\n\n      _this5.finalize(new Error('opening handshake has timed out'));\n    });\n  }\n\n  this._req.on('error', function (error) {\n    if (_this5._req.aborted) return;\n    _this5._req = null;\n\n    _this5.finalize(error);\n  });\n\n  this._req.on('response', function (res) {\n    if (!_this5.emit('unexpected-response', _this5._req, res)) {\n      _this5._req.abort();\n\n      _this5.finalize(new Error(\"unexpected server response (\".concat(res.statusCode, \")\")));\n    }\n  });\n\n  this._req.on('upgrade', function (res, socket, head) {\n    _this5.emit('headers', res.headers, res); //\n    // The user may have closed the connection from a listener of the `headers`\n    // event.\n    //\n\n\n    if (_this5.readyState !== WebSocket.CONNECTING) return;\n    _this5._req = null;\n    var digest = crypto.createHash('sha1').update(key + constants.GUID, 'binary').digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      socket.destroy();\n      return _this5.finalize(new Error('invalid server key'));\n    }\n\n    var serverProt = res.headers['sec-websocket-protocol'];\n    var protList = (options.protocol || '').split(/, */);\n    var protError;\n\n    if (!options.protocol && serverProt) {\n      protError = 'server sent a subprotocol even though none requested';\n    } else if (options.protocol && !serverProt) {\n      protError = 'server sent no subprotocol even though requested';\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\n      protError = 'server responded with an invalid protocol';\n    }\n\n    if (protError) {\n      socket.destroy();\n      return _this5.finalize(new Error(protError));\n    }\n\n    if (serverProt) _this5.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        var serverExtensions = Extensions.parse(res.headers['sec-websocket-extensions']);\n\n        if (serverExtensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(serverExtensions[PerMessageDeflate.extensionName]);\n          _this5.extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        socket.destroy();\n\n        _this5.finalize(new Error('invalid Sec-WebSocket-Extensions header'));\n\n        return;\n      }\n    }\n\n    _this5.setSocket(socket, head);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}