{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n'use strict';\n\nvar _defineProperty = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/inherits\");\n\nvar safeBuffer = require('safe-buffer');\n\nvar EventEmitter = require('events');\n\nvar crypto = require('crypto');\n\nvar Ultron = require('ultron');\n\nvar http = require('http');\n\nvar url = require('url');\n\nvar PerMessageDeflate = require('./PerMessageDeflate');\n\nvar Extensions = require('./Extensions');\n\nvar constants = require('./Constants');\n\nvar WebSocket = require('./WebSocket');\n\nvar Buffer = safeBuffer.Buffer;\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\n\nvar WebSocketServer =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(WebSocketServer, _EventEmitter);\n\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.path Accept only connections matching this path\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Function} callback A listener for the `listening` event\n   */\n  function WebSocketServer(options, callback) {\n    var _this;\n\n    _classCallCheck(this, WebSocketServer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebSocketServer).call(this));\n    options = Object.assign({\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null\n    }, options);\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError('missing or invalid options');\n    }\n\n    if (options.port != null) {\n      _this._server = http.createServer(function (req, res) {\n        var body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n\n      _this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      _this._server = options.server;\n    }\n\n    if (_this._server) {\n      _this._ultron = new Ultron(_this._server);\n\n      _this._ultron.on('listening', function () {\n        return _this.emit('listening');\n      });\n\n      _this._ultron.on('error', function (err) {\n        return _this.emit('error', err);\n      });\n\n      _this._ultron.on('upgrade', function (req, socket, head) {\n        _this.handleUpgrade(req, socket, head, function (client) {\n          _this.emit('connection', client, req);\n        });\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) _this.clients = new Set();\n    _this.options = options;\n    return _this;\n  }\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  _createClass(WebSocketServer, [{\n    key: \"close\",\n    value: function close(cb) {\n      //\n      // Terminate all associated clients.\n      //\n      if (this.clients) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.clients[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var client = _step.value;\n            client.terminate();\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      var server = this._server;\n\n      if (server) {\n        this._ultron.destroy();\n\n        this._ultron = this._server = null; //\n        // Close the http server if it was internally created.\n        //\n\n        if (this.options.port != null) return server.close(cb);\n      }\n\n      if (cb) cb();\n    }\n    /**\n     * See if a given request should be handled by this server instance.\n     *\n     * @param {http.IncomingMessage} req Request object to inspect\n     * @return {Boolean} `true` if the request is valid, else `false`\n     * @public\n     */\n\n  }, {\n    key: \"shouldHandle\",\n    value: function shouldHandle(req) {\n      if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Handle a HTTP Upgrade request.\n     *\n     * @param {http.IncomingMessage} req The request object\n     * @param {net.Socket} socket The network socket between the server and client\n     * @param {Buffer} head The first packet of the upgraded stream\n     * @param {Function} cb Callback\n     * @public\n     */\n\n  }, {\n    key: \"handleUpgrade\",\n    value: function handleUpgrade(req, socket, head, cb) {\n      var _this2 = this;\n\n      socket.on('error', socketError);\n      var version = +req.headers['sec-websocket-version'];\n      var extensions = {};\n\n      if (req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' || !req.headers['sec-websocket-key'] || version !== 8 && version !== 13 || !this.shouldHandle(req)) {\n        return abortConnection(socket, 400);\n      }\n\n      if (this.options.perMessageDeflate) {\n        var perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n\n        try {\n          var offers = Extensions.parse(req.headers['sec-websocket-extensions']);\n\n          if (offers[PerMessageDeflate.extensionName]) {\n            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n          }\n        } catch (err) {\n          return abortConnection(socket, 400);\n        }\n      }\n\n      var protocol = (req.headers['sec-websocket-protocol'] || '').split(/, */); //\n      // Optionally call external protocol selection handler.\n      //\n\n      if (this.options.handleProtocols) {\n        protocol = this.options.handleProtocols(protocol, req);\n        if (protocol === false) return abortConnection(socket, 401);\n      } else {\n        protocol = protocol[0];\n      } //\n      // Optionally call external client verification handler.\n      //\n\n\n      if (this.options.verifyClient) {\n        var info = {\n          origin: req.headers[\"\".concat(version === 8 ? 'sec-websocket-origin' : 'origin')],\n          secure: !!(req.connection.authorized || req.connection.encrypted),\n          req: req\n        };\n\n        if (this.options.verifyClient.length === 2) {\n          this.options.verifyClient(info, function (verified, code, message) {\n            if (!verified) return abortConnection(socket, code || 401, message);\n\n            _this2.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n          });\n          return;\n        }\n\n        if (!this.options.verifyClient(info)) return abortConnection(socket, 401);\n      }\n\n      this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n    }\n    /**\n     * Upgrade the connection to WebSocket.\n     *\n     * @param {String} protocol The chosen subprotocol\n     * @param {Object} extensions The accepted extensions\n     * @param {Number} version The WebSocket protocol version\n     * @param {http.IncomingMessage} req The request object\n     * @param {net.Socket} socket The network socket between the server and client\n     * @param {Buffer} head The first packet of the upgraded stream\n     * @param {Function} cb Callback\n     * @private\n     */\n\n  }, {\n    key: \"completeUpgrade\",\n    value: function completeUpgrade(protocol, extensions, version, req, socket, head, cb) {\n      var _this3 = this;\n\n      //\n      // Destroy the socket if the client has already sent a FIN packet.\n      //\n      if (!socket.readable || !socket.writable) return socket.destroy();\n      var key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + constants.GUID, 'binary').digest('base64');\n      var headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', \"Sec-WebSocket-Accept: \".concat(key)];\n      if (protocol) headers.push(\"Sec-WebSocket-Protocol: \".concat(protocol));\n\n      if (extensions[PerMessageDeflate.extensionName]) {\n        var params = extensions[PerMessageDeflate.extensionName].params;\n        var value = Extensions.format(_defineProperty({}, PerMessageDeflate.extensionName, [params]));\n        headers.push(\"Sec-WebSocket-Extensions: \".concat(value));\n      } //\n      // Allow external modification/inspection of handshake headers.\n      //\n\n\n      this.emit('headers', headers, req);\n      socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n      var client = new WebSocket([socket, head], null, {\n        maxPayload: this.options.maxPayload,\n        protocolVersion: version,\n        extensions: extensions,\n        protocol: protocol\n      });\n\n      if (this.clients) {\n        this.clients.add(client);\n        client.on('close', function () {\n          return _this3.clients.delete(client);\n        });\n      }\n\n      socket.removeListener('error', socketError);\n      cb(client);\n    }\n  }]);\n\n  return WebSocketServer;\n}(EventEmitter);\n\nmodule.exports = WebSocketServer;\n/**\n * Handle premature socket errors.\n *\n * @private\n */\n\nfunction socketError() {\n  this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @private\n */\n\n\nfunction abortConnection(socket, code, message) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    socket.write(\"HTTP/1.1 \".concat(code, \" \").concat(http.STATUS_CODES[code], \"\\r\\n\") + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + \"Content-Length: \".concat(Buffer.byteLength(message), \"\\r\\n\") + '\\r\\n' + message);\n  }\n\n  socket.removeListener('error', socketError);\n  socket.destroy();\n}","map":null,"metadata":{},"sourceType":"script"}