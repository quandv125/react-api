{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Volumes/Data/React/react-api/node_modules/@babel/runtime/helpers/createClass\");\n\nvar safeBuffer = require('safe-buffer');\n\nvar Limiter = require('async-limiter');\n\nvar zlib = require('zlib');\n\nvar bufferUtil = require('./BufferUtil');\n\nvar Buffer = safeBuffer.Buffer;\nvar TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nvar EMPTY_BLOCK = Buffer.from([0x00]);\nvar kWriteInProgress = Symbol('write-in-progress');\nvar kPendingClose = Symbol('pending-close');\nvar kTotalLength = Symbol('total-length');\nvar kCallback = Symbol('callback');\nvar kBuffers = Symbol('buffers');\nvar kError = Symbol('error');\nvar kOwner = Symbol('owner'); //\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\n\nvar zlibLimiter;\n/**\n * permessage-deflate implementation.\n */\n\nvar PerMessageDeflate =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Number} options.level The value of zlib's `level` param\n   * @param {Number} options.memLevel The value of zlib's `memLevel` param\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  function PerMessageDeflate(options, isServer, maxPayload) {\n    _classCallCheck(this, PerMessageDeflate);\n\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n\n    if (!zlibLimiter) {\n      var concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter({\n        concurrency: concurrency\n      });\n    }\n  }\n  /**\n   * @type {String}\n   */\n\n\n  _createClass(PerMessageDeflate, [{\n    key: \"offer\",\n\n    /**\n     * Create extension parameters offer.\n     *\n     * @return {Object} Extension parameters\n     * @public\n     */\n    value: function offer() {\n      var params = {};\n\n      if (this._options.serverNoContextTakeover) {\n        params.server_no_context_takeover = true;\n      }\n\n      if (this._options.clientNoContextTakeover) {\n        params.client_no_context_takeover = true;\n      }\n\n      if (this._options.serverMaxWindowBits) {\n        params.server_max_window_bits = this._options.serverMaxWindowBits;\n      }\n\n      if (this._options.clientMaxWindowBits) {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      } else if (this._options.clientMaxWindowBits == null) {\n        params.client_max_window_bits = true;\n      }\n\n      return params;\n    }\n    /**\n     * Accept extension offer.\n     *\n     * @param {Array} paramsList Extension parameters\n     * @return {Object} Accepted configuration\n     * @public\n     */\n\n  }, {\n    key: \"accept\",\n    value: function accept(paramsList) {\n      paramsList = this.normalizeParams(paramsList);\n      var params;\n\n      if (this._isServer) {\n        params = this.acceptAsServer(paramsList);\n      } else {\n        params = this.acceptAsClient(paramsList);\n      }\n\n      this.params = params;\n      return params;\n    }\n    /**\n     * Releases all resources used by the extension.\n     *\n     * @public\n     */\n\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      if (this._inflate) {\n        if (this._inflate[kWriteInProgress]) {\n          this._inflate[kPendingClose] = true;\n        } else {\n          this._inflate.close();\n\n          this._inflate = null;\n        }\n      }\n\n      if (this._deflate) {\n        if (this._deflate[kWriteInProgress]) {\n          this._deflate[kPendingClose] = true;\n        } else {\n          this._deflate.close();\n\n          this._deflate = null;\n        }\n      }\n    }\n    /**\n     * Accept extension offer from client.\n     *\n     * @param {Array} paramsList Extension parameters\n     * @return {Object} Accepted configuration\n     * @private\n     */\n\n  }, {\n    key: \"acceptAsServer\",\n    value: function acceptAsServer(paramsList) {\n      var _this = this;\n\n      var accepted = {};\n      var result = paramsList.some(function (params) {\n        if (_this._options.serverNoContextTakeover === false && params.server_no_context_takeover || _this._options.serverMaxWindowBits === false && params.server_max_window_bits || typeof _this._options.serverMaxWindowBits === 'number' && typeof params.server_max_window_bits === 'number' && _this._options.serverMaxWindowBits > params.server_max_window_bits || typeof _this._options.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n          return;\n        }\n\n        if (_this._options.serverNoContextTakeover || params.server_no_context_takeover) {\n          accepted.server_no_context_takeover = true;\n        }\n\n        if (_this._options.clientNoContextTakeover || _this._options.clientNoContextTakeover !== false && params.client_no_context_takeover) {\n          accepted.client_no_context_takeover = true;\n        }\n\n        if (typeof _this._options.serverMaxWindowBits === 'number') {\n          accepted.server_max_window_bits = _this._options.serverMaxWindowBits;\n        } else if (typeof params.server_max_window_bits === 'number') {\n          accepted.server_max_window_bits = params.server_max_window_bits;\n        }\n\n        if (typeof _this._options.clientMaxWindowBits === 'number') {\n          accepted.client_max_window_bits = _this._options.clientMaxWindowBits;\n        } else if (_this._options.clientMaxWindowBits !== false && typeof params.client_max_window_bits === 'number') {\n          accepted.client_max_window_bits = params.client_max_window_bits;\n        }\n\n        return true;\n      });\n      if (!result) throw new Error(\"Doesn't support the offered configuration\");\n      return accepted;\n    }\n    /**\n     * Accept extension response from server.\n     *\n     * @param {Array} paramsList Extension parameters\n     * @return {Object} Accepted configuration\n     * @private\n     */\n\n  }, {\n    key: \"acceptAsClient\",\n    value: function acceptAsClient(paramsList) {\n      var params = paramsList[0];\n\n      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n        throw new Error('Invalid value for \"client_no_context_takeover\"');\n      }\n\n      if (typeof this._options.clientMaxWindowBits === 'number' && (!params.client_max_window_bits || params.client_max_window_bits > this._options.clientMaxWindowBits) || this._options.clientMaxWindowBits === false && params.client_max_window_bits) {\n        throw new Error('Invalid value for \"client_max_window_bits\"');\n      }\n\n      return params;\n    }\n    /**\n     * Normalize extensions parameters.\n     *\n     * @param {Array} paramsList Extension parameters\n     * @return {Array} Normalized extensions parameters\n     * @private\n     */\n\n  }, {\n    key: \"normalizeParams\",\n    value: function normalizeParams(paramsList) {\n      var _this2 = this;\n\n      return paramsList.map(function (params) {\n        Object.keys(params).forEach(function (key) {\n          var value = params[key];\n\n          if (value.length > 1) {\n            throw new Error(\"Multiple extension parameters for \".concat(key));\n          }\n\n          value = value[0];\n\n          switch (key) {\n            case 'server_no_context_takeover':\n            case 'client_no_context_takeover':\n              if (value !== true) {\n                throw new Error(\"invalid extension parameter value for \".concat(key, \" (\").concat(value, \")\"));\n              }\n\n              params[key] = true;\n              break;\n\n            case 'server_max_window_bits':\n            case 'client_max_window_bits':\n              if (typeof value === 'string') {\n                value = parseInt(value, 10);\n\n                if (Number.isNaN(value) || value < zlib.Z_MIN_WINDOWBITS || value > zlib.Z_MAX_WINDOWBITS) {\n                  throw new Error(\"invalid extension parameter value for \".concat(key, \" (\").concat(value, \")\"));\n                }\n              }\n\n              if (!_this2._isServer && value === true) {\n                throw new Error(\"Missing extension parameter value for \".concat(key));\n              }\n\n              params[key] = value;\n              break;\n\n            default:\n              throw new Error(\"Not defined extension parameter (\".concat(key, \")\"));\n          }\n        });\n        return params;\n      });\n    }\n    /**\n     * Decompress data. Concurrency limited by async-limiter.\n     *\n     * @param {Buffer} data Compressed data\n     * @param {Boolean} fin Specifies whether or not this is the last fragment\n     * @param {Function} callback Callback\n     * @public\n     */\n\n  }, {\n    key: \"decompress\",\n    value: function decompress(data, fin, callback) {\n      var _this3 = this;\n\n      zlibLimiter.push(function (done) {\n        _this3._decompress(data, fin, function (err, result) {\n          done();\n          callback(err, result);\n        });\n      });\n    }\n    /**\n     * Compress data. Concurrency limited by async-limiter.\n     *\n     * @param {Buffer} data Data to compress\n     * @param {Boolean} fin Specifies whether or not this is the last fragment\n     * @param {Function} callback Callback\n     * @public\n     */\n\n  }, {\n    key: \"compress\",\n    value: function compress(data, fin, callback) {\n      var _this4 = this;\n\n      zlibLimiter.push(function (done) {\n        _this4._compress(data, fin, function (err, result) {\n          done();\n          callback(err, result);\n        });\n      });\n    }\n    /**\n     * Decompress data.\n     *\n     * @param {Buffer} data Compressed data\n     * @param {Boolean} fin Specifies whether or not this is the last fragment\n     * @param {Function} callback Callback\n     * @private\n     */\n\n  }, {\n    key: \"_decompress\",\n    value: function _decompress(data, fin, callback) {\n      var _this5 = this;\n\n      var endpoint = this._isServer ? 'client' : 'server';\n\n      if (!this._inflate) {\n        var key = \"\".concat(endpoint, \"_max_window_bits\");\n        var windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n        this._inflate = zlib.createInflateRaw({\n          windowBits: windowBits\n        });\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n        this._inflate[kOwner] = this;\n\n        this._inflate.on('error', inflateOnError);\n\n        this._inflate.on('data', inflateOnData);\n      }\n\n      this._inflate[kCallback] = callback;\n      this._inflate[kWriteInProgress] = true;\n\n      this._inflate.write(data);\n\n      if (fin) this._inflate.write(TRAILER);\n\n      this._inflate.flush(function () {\n        var err = _this5._inflate[kError];\n\n        if (err) {\n          _this5._inflate.close();\n\n          _this5._inflate = null;\n          callback(err);\n          return;\n        }\n\n        var data = bufferUtil.concat(_this5._inflate[kBuffers], _this5._inflate[kTotalLength]);\n\n        if (fin && _this5.params[\"\".concat(endpoint, \"_no_context_takeover\")] || _this5._inflate[kPendingClose]) {\n          _this5._inflate.close();\n\n          _this5._inflate = null;\n        } else {\n          _this5._inflate[kWriteInProgress] = false;\n          _this5._inflate[kTotalLength] = 0;\n          _this5._inflate[kBuffers] = [];\n        }\n\n        callback(null, data);\n      });\n    }\n    /**\n     * Compress data.\n     *\n     * @param {Buffer} data Data to compress\n     * @param {Boolean} fin Specifies whether or not this is the last fragment\n     * @param {Function} callback Callback\n     * @private\n     */\n\n  }, {\n    key: \"_compress\",\n    value: function _compress(data, fin, callback) {\n      var _this6 = this;\n\n      if (!data || data.length === 0) {\n        process.nextTick(callback, null, EMPTY_BLOCK);\n        return;\n      }\n\n      var endpoint = this._isServer ? 'server' : 'client';\n\n      if (!this._deflate) {\n        var key = \"\".concat(endpoint, \"_max_window_bits\");\n        var windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n        this._deflate = zlib.createDeflateRaw({\n          memLevel: this._options.memLevel,\n          level: this._options.level,\n          flush: zlib.Z_SYNC_FLUSH,\n          windowBits: windowBits\n        });\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = []; //\n        // `zlib.DeflateRaw` emits an `'error'` event only when an attempt to use\n        // it is made after it has already been closed. This cannot happen here,\n        // so we only add a listener for the `'data'` event.\n        //\n\n        this._deflate.on('data', deflateOnData);\n      }\n\n      this._deflate[kWriteInProgress] = true;\n\n      this._deflate.write(data);\n\n      this._deflate.flush(zlib.Z_SYNC_FLUSH, function () {\n        var data = bufferUtil.concat(_this6._deflate[kBuffers], _this6._deflate[kTotalLength]);\n        if (fin) data = data.slice(0, data.length - 4);\n\n        if (fin && _this6.params[\"\".concat(endpoint, \"_no_context_takeover\")] || _this6._deflate[kPendingClose]) {\n          _this6._deflate.close();\n\n          _this6._deflate = null;\n        } else {\n          _this6._deflate[kWriteInProgress] = false;\n          _this6._deflate[kTotalLength] = 0;\n          _this6._deflate[kBuffers] = [];\n        }\n\n        callback(null, data);\n      });\n    }\n  }], [{\n    key: \"extensionName\",\n    get: function get() {\n      return 'permessage-deflate';\n    }\n  }]);\n\n  return PerMessageDeflate;\n}();\n\nmodule.exports = PerMessageDeflate;\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\n\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (this[kOwner]._maxPayload < 1 || this[kTotalLength] <= this[kOwner]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new Error('max payload size exceeded');\n  this[kError].closeCode = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\n\n\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kOwner]._inflate = null;\n  this[kCallback](err);\n}","map":null,"metadata":{},"sourceType":"script"}