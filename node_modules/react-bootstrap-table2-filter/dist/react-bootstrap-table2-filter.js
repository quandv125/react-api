(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactBootstrapTable2Filter"] = factory(require("react"));
	else
		root["ReactBootstrapTable2Filter"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var LIKE = exports.LIKE = 'LIKE';
var EQ = exports.EQ = '=';
var NE = exports.NE = '!=';
var GT = exports.GT = '>';
var GE = exports.GE = '>=';
var LT = exports.LT = '<';
var LE = exports.LE = '<=';

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var FILTER_TYPE = exports.FILTER_TYPE = {
  TEXT: 'TEXT',
  SELECT: 'SELECT',
  MULTISELECT: 'MULTISELECT',
  NUMBER: 'NUMBER',
  DATE: 'DATE'
};

var FILTER_DELAY = exports.FILTER_DELAY = 500;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(6)();
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.customFilter = exports.dateFilter = exports.numberFilter = exports.multiSelectFilter = exports.selectFilter = exports.textFilter = exports.Comparator = exports.FILTER_TYPES = undefined;

var _text = __webpack_require__(5);

var _text2 = _interopRequireDefault(_text);

var _select = __webpack_require__(10);

var _select2 = _interopRequireDefault(_select);

var _multiselect = __webpack_require__(11);

var _multiselect2 = _interopRequireDefault(_multiselect);

var _number = __webpack_require__(12);

var _number2 = _interopRequireDefault(_number);

var _date = __webpack_require__(13);

var _date2 = _interopRequireDefault(_date);

var _wrapper = __webpack_require__(14);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _comparison = __webpack_require__(0);

var Comparison = _interopRequireWildcard(_comparison);

var _const = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    wrapperFactory: _wrapper2.default,
    options: options
  };
};

var FILTER_TYPES = exports.FILTER_TYPES = _const.FILTER_TYPE;

var Comparator = exports.Comparator = Comparison;

var textFilter = exports.textFilter = function textFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    Filter: _text2.default,
    props: props
  };
};

var selectFilter = exports.selectFilter = function selectFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    Filter: _select2.default,
    props: props
  };
};

var multiSelectFilter = exports.multiSelectFilter = function multiSelectFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    Filter: _multiselect2.default,
    props: props
  };
};

var numberFilter = exports.numberFilter = function numberFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    Filter: _number2.default,
    props: props
  };
};

var dateFilter = exports.dateFilter = function dateFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    Filter: _date2.default,
    props: props
  };
};

var customFilter = exports.customFilter = function customFilter() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    props: props
  };
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _comparison = __webpack_require__(0);

var _const = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint react/prop-types: 0 */
/* eslint no-return-assign: 0 */


var TextFilter = function (_Component) {
  _inherits(TextFilter, _Component);

  function TextFilter(props) {
    _classCallCheck(this, TextFilter);

    var _this = _possibleConstructorReturn(this, (TextFilter.__proto__ || Object.getPrototypeOf(TextFilter)).call(this, props));

    _this.filter = _this.filter.bind(_this);
    _this.handleClick = _this.handleClick.bind(_this);
    _this.timeout = null;
    _this.state = {
      value: props.defaultValue
    };
    return _this;
  }

  _createClass(TextFilter, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var _props = this.props,
          onFilter = _props.onFilter,
          getFilter = _props.getFilter,
          column = _props.column;

      var defaultValue = this.input.value;

      if (defaultValue) {
        onFilter(this.props.column, _const.FILTER_TYPE.TEXT)(defaultValue);
      }

      // export onFilter function to allow users to access
      if (getFilter) {
        getFilter(function (filterVal) {
          _this2.setState(function () {
            return { value: filterVal };
          });
          onFilter(column, _const.FILTER_TYPE.TEXT)(filterVal);
        });
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.defaultValue !== this.props.defaultValue) {
        this.applyFilter(nextProps.defaultValue);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.cleanTimer();
    }
  }, {
    key: 'filter',
    value: function filter(e) {
      var _this3 = this;

      e.stopPropagation();
      this.cleanTimer();
      var filterValue = e.target.value;
      this.setState(function () {
        return { value: filterValue };
      });
      this.timeout = setTimeout(function () {
        _this3.props.onFilter(_this3.props.column, _const.FILTER_TYPE.TEXT)(filterValue);
      }, this.props.delay);
    }
  }, {
    key: 'cleanTimer',
    value: function cleanTimer() {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
    }
  }, {
    key: 'cleanFiltered',
    value: function cleanFiltered() {
      var value = this.props.defaultValue;
      this.setState(function () {
        return { value: value };
      });
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.TEXT)(value);
    }
  }, {
    key: 'applyFilter',
    value: function applyFilter(filterText) {
      this.setState(function () {
        return { value: filterText };
      });
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.TEXT)(filterText);
    }
  }, {
    key: 'handleClick',
    value: function handleClick(e) {
      e.stopPropagation();
      if (this.props.onClick) {
        this.props.onClick(e);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var _props2 = this.props,
          placeholder = _props2.placeholder,
          text = _props2.column.text,
          style = _props2.style,
          className = _props2.className,
          onFilter = _props2.onFilter,
          caseSensitive = _props2.caseSensitive,
          defaultValue = _props2.defaultValue,
          getFilter = _props2.getFilter,
          rest = _objectWithoutProperties(_props2, ['placeholder', 'column', 'style', 'className', 'onFilter', 'caseSensitive', 'defaultValue', 'getFilter']);

      // stopPropagation for onClick event is try to prevent sort was triggered.


      return _react2.default.createElement('input', _extends({}, rest, {
        ref: function ref(n) {
          return _this4.input = n;
        },
        type: 'text',
        className: 'filter text-filter form-control ' + className,
        style: style,
        onChange: this.filter,
        onClick: this.handleClick,
        placeholder: placeholder || 'Enter ' + text + '...',
        value: this.state.value
      }));
    }
  }]);

  return TextFilter;
}(_react.Component);

TextFilter.propTypes = {
  onFilter: _propTypes.PropTypes.func.isRequired,
  column: _propTypes.PropTypes.object.isRequired,
  comparator: _propTypes.PropTypes.oneOf([_comparison.LIKE, _comparison.EQ]),
  defaultValue: _propTypes.PropTypes.string,
  delay: _propTypes.PropTypes.number,
  placeholder: _propTypes.PropTypes.string,
  style: _propTypes.PropTypes.object,
  className: _propTypes.PropTypes.string,
  caseSensitive: _propTypes.PropTypes.bool,
  getFilter: _propTypes.PropTypes.func
};

TextFilter.defaultProps = {
  delay: _const.FILTER_DELAY,
  defaultValue: '',
  caseSensitive: false
};

exports.default = TextFilter;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(7);
var invariant = __webpack_require__(8);
var ReactPropTypesSecret = __webpack_require__(9);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _comparison = __webpack_require__(0);

var _const = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint no-return-assign: 0 */
/* eslint react/no-unused-prop-types: 0 */


function optionsEquals(currOpts, prevOpts) {
  var keys = Object.keys(currOpts);
  for (var i = 0; i < keys.length; i += 1) {
    if (currOpts[keys[i]] !== prevOpts[keys[i]]) {
      return false;
    }
  }
  return Object.keys(currOpts).length === Object.keys(prevOpts).length;
}

var SelectFilter = function (_Component) {
  _inherits(SelectFilter, _Component);

  function SelectFilter(props) {
    _classCallCheck(this, SelectFilter);

    var _this = _possibleConstructorReturn(this, (SelectFilter.__proto__ || Object.getPrototypeOf(SelectFilter)).call(this, props));

    _this.filter = _this.filter.bind(_this);
    var isSelected = props.options[props.defaultValue] !== undefined;
    _this.state = { isSelected: isSelected };
    return _this;
  }

  _createClass(SelectFilter, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var _props = this.props,
          column = _props.column,
          onFilter = _props.onFilter,
          getFilter = _props.getFilter;


      var value = this.selectInput.value;
      if (value && value !== '') {
        onFilter(column, _const.FILTER_TYPE.SELECT)(value);
      }

      // export onFilter function to allow users to access
      if (getFilter) {
        getFilter(function (filterVal) {
          _this2.setState(function () {
            return { isSelected: filterVal !== '' };
          });
          _this2.selectInput.value = filterVal;

          onFilter(column, _const.FILTER_TYPE.SELECT)(filterVal);
        });
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var needFilter = false;
      if (this.props.defaultValue !== prevProps.defaultValue) {
        needFilter = true;
      } else if (!optionsEquals(this.props.options, prevProps.options)) {
        needFilter = true;
      }
      if (needFilter) {
        var value = this.selectInput.value;
        if (value) {
          this.props.onFilter(this.props.column, _const.FILTER_TYPE.SELECT)(value);
        }
      }
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      var optionTags = [];
      var _props2 = this.props,
          options = _props2.options,
          placeholder = _props2.placeholder,
          column = _props2.column,
          withoutEmptyOption = _props2.withoutEmptyOption;

      if (!withoutEmptyOption) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: '-1', value: '' },
          placeholder || 'Select ' + column.text + '...'
        ));
      }
      Object.keys(options).forEach(function (key) {
        return optionTags.push(_react2.default.createElement(
          'option',
          { key: key, value: key },
          options[key]
        ));
      });
      return optionTags;
    }
  }, {
    key: 'cleanFiltered',
    value: function cleanFiltered() {
      var value = this.props.defaultValue !== undefined ? this.props.defaultValue : '';
      this.setState(function () {
        return { isSelected: value !== '' };
      });
      this.selectInput.value = value;
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.SELECT)(value);
    }
  }, {
    key: 'applyFilter',
    value: function applyFilter(value) {
      this.selectInput.value = value;
      this.setState(function () {
        return { isSelected: value !== '' };
      });
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.SELECT)(value);
    }
  }, {
    key: 'filter',
    value: function filter(e) {
      var value = e.target.value;

      this.setState(function () {
        return { isSelected: value !== '' };
      });
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.SELECT)(value);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props3 = this.props,
          style = _props3.style,
          className = _props3.className,
          defaultValue = _props3.defaultValue,
          onFilter = _props3.onFilter,
          column = _props3.column,
          options = _props3.options,
          comparator = _props3.comparator,
          withoutEmptyOption = _props3.withoutEmptyOption,
          caseSensitive = _props3.caseSensitive,
          getFilter = _props3.getFilter,
          rest = _objectWithoutProperties(_props3, ['style', 'className', 'defaultValue', 'onFilter', 'column', 'options', 'comparator', 'withoutEmptyOption', 'caseSensitive', 'getFilter']);

      var selectClass = 'filter select-filter form-control ' + className + ' ' + (this.state.isSelected ? '' : 'placeholder-selected');

      return _react2.default.createElement(
        'select',
        _extends({}, rest, {
          ref: function ref(n) {
            return _this3.selectInput = n;
          },
          style: style,
          className: selectClass,
          onChange: this.filter,
          onClick: function onClick(e) {
            return e.stopPropagation();
          },
          defaultValue: defaultValue !== undefined ? defaultValue : ''
        }),
        this.getOptions()
      );
    }
  }]);

  return SelectFilter;
}(_react.Component);

SelectFilter.propTypes = {
  onFilter: _propTypes2.default.func.isRequired,
  column: _propTypes2.default.object.isRequired,
  options: _propTypes2.default.object.isRequired,
  comparator: _propTypes2.default.oneOf([_comparison.LIKE, _comparison.EQ]),
  placeholder: _propTypes2.default.string,
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  withoutEmptyOption: _propTypes2.default.bool,
  defaultValue: _propTypes2.default.any,
  caseSensitive: _propTypes2.default.bool,
  getFilter: _propTypes2.default.func
};

SelectFilter.defaultProps = {
  defaultValue: '',
  className: '',
  withoutEmptyOption: false,
  comparator: _comparison.EQ,
  caseSensitive: true
};

exports.default = SelectFilter;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _comparison = __webpack_require__(0);

var _const = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint no-return-assign: 0 */
/* eslint no-param-reassign: 0 */
/* eslint react/no-unused-prop-types: 0 */


function optionsEquals(currOpts, prevOpts) {
  var keys = Object.keys(currOpts);
  for (var i = 0; i < keys.length; i += 1) {
    if (currOpts[keys[i]] !== prevOpts[keys[i]]) {
      return false;
    }
  }
  return Object.keys(currOpts).length === Object.keys(prevOpts).length;
}

var getSelections = function getSelections(container) {
  return Array.from(container.selectedOptions).map(function (item) {
    return item.value;
  });
};

var MultiSelectFilter = function (_Component) {
  _inherits(MultiSelectFilter, _Component);

  function MultiSelectFilter(props) {
    _classCallCheck(this, MultiSelectFilter);

    var _this = _possibleConstructorReturn(this, (MultiSelectFilter.__proto__ || Object.getPrototypeOf(MultiSelectFilter)).call(this, props));

    _this.filter = _this.filter.bind(_this);
    _this.applyFilter = _this.applyFilter.bind(_this);
    var isSelected = props.defaultValue.map(function (item) {
      return props.options[item];
    }).length > 0;
    _this.state = { isSelected: isSelected };
    return _this;
  }

  _createClass(MultiSelectFilter, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var getFilter = this.props.getFilter;


      var value = getSelections(this.selectInput);
      if (value && value.length > 0) {
        this.applyFilter(value);
      }

      // export onFilter function to allow users to access
      if (getFilter) {
        getFilter(function (filterVal) {
          _this2.selectInput.value = filterVal;
          _this2.applyFilter(filterVal);
        });
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var needFilter = false;
      if (this.props.defaultValue !== prevProps.defaultValue) {
        needFilter = true;
      } else if (!optionsEquals(this.props.options, prevProps.options)) {
        needFilter = true;
      }
      if (needFilter) {
        this.applyFilter(this.selectInput.value);
      }
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      var optionTags = [];
      var _props = this.props,
          options = _props.options,
          placeholder = _props.placeholder,
          column = _props.column,
          withoutEmptyOption = _props.withoutEmptyOption;

      if (!withoutEmptyOption) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: '-1', value: '' },
          placeholder || 'Select ' + column.text + '...'
        ));
      }
      Object.keys(options).forEach(function (key) {
        return optionTags.push(_react2.default.createElement(
          'option',
          { key: key, value: key },
          options[key]
        ));
      });
      return optionTags;
    }
  }, {
    key: 'cleanFiltered',
    value: function cleanFiltered() {
      var value = this.props.defaultValue !== undefined ? this.props.defaultValue : [];
      this.selectInput.value = value;
      this.applyFilter(value);
    }
  }, {
    key: 'applyFilter',
    value: function applyFilter(value) {
      if (value.length === 1 && value[0] === '') {
        value = [];
      }
      this.setState(function () {
        return { isSelected: value.length > 0 };
      });
      this.props.onFilter(this.props.column, _const.FILTER_TYPE.MULTISELECT)(value);
    }
  }, {
    key: 'filter',
    value: function filter(e) {
      var value = getSelections(e.target);
      this.applyFilter(value);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props2 = this.props,
          style = _props2.style,
          className = _props2.className,
          defaultValue = _props2.defaultValue,
          onFilter = _props2.onFilter,
          column = _props2.column,
          options = _props2.options,
          comparator = _props2.comparator,
          withoutEmptyOption = _props2.withoutEmptyOption,
          caseSensitive = _props2.caseSensitive,
          getFilter = _props2.getFilter,
          rest = _objectWithoutProperties(_props2, ['style', 'className', 'defaultValue', 'onFilter', 'column', 'options', 'comparator', 'withoutEmptyOption', 'caseSensitive', 'getFilter']);

      var selectClass = 'filter select-filter form-control ' + className + ' ' + (this.state.isSelected ? '' : 'placeholder-selected');

      return _react2.default.createElement(
        'select',
        _extends({}, rest, {
          ref: function ref(n) {
            return _this3.selectInput = n;
          },
          style: style,
          multiple: true,
          className: selectClass,
          onChange: this.filter,
          onClick: function onClick(e) {
            return e.stopPropagation();
          },
          defaultValue: defaultValue !== undefined ? defaultValue : ''
        }),
        this.getOptions()
      );
    }
  }]);

  return MultiSelectFilter;
}(_react.Component);

MultiSelectFilter.propTypes = {
  onFilter: _propTypes2.default.func.isRequired,
  column: _propTypes2.default.object.isRequired,
  options: _propTypes2.default.object.isRequired,
  comparator: _propTypes2.default.oneOf([_comparison.LIKE, _comparison.EQ]),
  placeholder: _propTypes2.default.string,
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  withoutEmptyOption: _propTypes2.default.bool,
  defaultValue: _propTypes2.default.array,
  caseSensitive: _propTypes2.default.bool,
  getFilter: _propTypes2.default.func
};

MultiSelectFilter.defaultProps = {
  defaultValue: [],
  className: '',
  withoutEmptyOption: false,
  comparator: _comparison.EQ,
  caseSensitive: true
};

exports.default = MultiSelectFilter;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _comparison = __webpack_require__(0);

var Comparator = _interopRequireWildcard(_comparison);

var _const = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint jsx-a11y/no-static-element-interactions: 0 */
/* eslint react/require-default-props: 0 */
/* eslint no-return-assign: 0 */

var legalComparators = [Comparator.EQ, Comparator.NE, Comparator.GT, Comparator.GE, Comparator.LT, Comparator.LE];

var NumberFilter = function (_Component) {
  _inherits(NumberFilter, _Component);

  function NumberFilter(props) {
    _classCallCheck(this, NumberFilter);

    var _this = _possibleConstructorReturn(this, (NumberFilter.__proto__ || Object.getPrototypeOf(NumberFilter)).call(this, props));

    _this.comparators = props.comparators || legalComparators;
    _this.timeout = null;
    var isSelected = props.defaultValue !== undefined && props.defaultValue.number !== undefined;
    if (props.options && isSelected) {
      isSelected = props.options.indexOf(props.defaultValue.number) > -1;
    }
    _this.state = { isSelected: isSelected };
    _this.onChangeNumber = _this.onChangeNumber.bind(_this);
    _this.onChangeNumberSet = _this.onChangeNumberSet.bind(_this);
    _this.onChangeComparator = _this.onChangeComparator.bind(_this);
    return _this;
  }

  _createClass(NumberFilter, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var _props = this.props,
          column = _props.column,
          onFilter = _props.onFilter,
          getFilter = _props.getFilter;

      var comparator = this.numberFilterComparator.value;
      var number = this.numberFilter.value;
      if (comparator && number) {
        onFilter(column, _const.FILTER_TYPE.NUMBER)({ number: number, comparator: comparator });
      }

      // export onFilter function to allow users to access
      if (getFilter) {
        getFilter(function (filterVal) {
          _this2.setState(function () {
            return { isSelected: filterVal !== '' };
          });
          _this2.numberFilterComparator.value = filterVal.comparator;
          _this2.numberFilter.value = filterVal.number;

          onFilter(column, _const.FILTER_TYPE.NUMBER)({
            number: filterVal.number,
            comparator: filterVal.comparator
          });
        });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearTimeout(this.timeout);
    }
  }, {
    key: 'onChangeNumber',
    value: function onChangeNumber(e) {
      var _props2 = this.props,
          delay = _props2.delay,
          column = _props2.column,
          onFilter = _props2.onFilter;

      var comparator = this.numberFilterComparator.value;
      if (comparator === '') {
        return;
      }
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      var filterValue = e.target.value;
      this.timeout = setTimeout(function () {
        onFilter(column, _const.FILTER_TYPE.NUMBER)({ number: filterValue, comparator: comparator });
      }, delay);
    }
  }, {
    key: 'onChangeNumberSet',
    value: function onChangeNumberSet(e) {
      var _props3 = this.props,
          column = _props3.column,
          onFilter = _props3.onFilter;

      var comparator = this.numberFilterComparator.value;
      var value = e.target.value;

      this.setState(function () {
        return { isSelected: value !== '' };
      });
      // if (comparator === '') {
      //   return;
      // }
      onFilter(column, _const.FILTER_TYPE.NUMBER)({ number: value, comparator: comparator });
    }
  }, {
    key: 'onChangeComparator',
    value: function onChangeComparator(e) {
      var _props4 = this.props,
          column = _props4.column,
          onFilter = _props4.onFilter;

      var value = this.numberFilter.value;
      var comparator = e.target.value;
      // if (value === '') {
      //   return;
      // }
      onFilter(column, _const.FILTER_TYPE.NUMBER)({ number: value, comparator: comparator });
    }
  }, {
    key: 'getComparatorOptions',
    value: function getComparatorOptions() {
      var optionTags = [];
      var withoutEmptyComparatorOption = this.props.withoutEmptyComparatorOption;

      if (!withoutEmptyComparatorOption) {
        optionTags.push(_react2.default.createElement('option', { key: '-1' }));
      }
      for (var i = 0; i < this.comparators.length; i += 1) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: i, value: this.comparators[i] },
          this.comparators[i]
        ));
      }
      return optionTags;
    }
  }, {
    key: 'getNumberOptions',
    value: function getNumberOptions() {
      var optionTags = [];
      var _props5 = this.props,
          options = _props5.options,
          column = _props5.column,
          withoutEmptyNumberOption = _props5.withoutEmptyNumberOption;

      if (!withoutEmptyNumberOption) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: '-1', value: '' },
          this.props.placeholder || 'Select ' + column.text + '...'
        ));
      }
      for (var i = 0; i < options.length; i += 1) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: i, value: options[i] },
          options[i]
        ));
      }
      return optionTags;
    }
  }, {
    key: 'applyFilter',
    value: function applyFilter(filterObj) {
      var _props6 = this.props,
          column = _props6.column,
          onFilter = _props6.onFilter;
      var number = filterObj.number,
          comparator = filterObj.comparator;

      this.setState(function () {
        return { isSelected: number !== '' };
      });
      this.numberFilterComparator.value = comparator;
      this.numberFilter.value = number;
      onFilter(column, _const.FILTER_TYPE.NUMBER)({ number: number, comparator: comparator });
    }
  }, {
    key: 'cleanFiltered',
    value: function cleanFiltered() {
      var _props7 = this.props,
          column = _props7.column,
          onFilter = _props7.onFilter,
          defaultValue = _props7.defaultValue;

      var value = defaultValue ? defaultValue.number : '';
      var comparator = defaultValue ? defaultValue.comparator : '';
      this.setState(function () {
        return { isSelected: value !== '' };
      });
      this.numberFilterComparator.value = comparator;
      this.numberFilter.value = value;
      onFilter(column, _const.FILTER_TYPE.NUMBER)({ number: value, comparator: comparator });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var isSelected = this.state.isSelected;
      var _props8 = this.props,
          defaultValue = _props8.defaultValue,
          column = _props8.column,
          options = _props8.options,
          style = _props8.style,
          className = _props8.className,
          numberStyle = _props8.numberStyle,
          numberClassName = _props8.numberClassName,
          comparatorStyle = _props8.comparatorStyle,
          comparatorClassName = _props8.comparatorClassName,
          placeholder = _props8.placeholder;

      var selectClass = '\n      select-filter \n      number-filter-input \n      form-control \n      ' + numberClassName + ' \n      ' + (!isSelected ? 'placeholder-selected' : '') + '\n    ';

      return _react2.default.createElement(
        'div',
        {
          onClick: function onClick(e) {
            return e.stopPropagation();
          },
          className: 'filter number-filter ' + className,
          style: style
        },
        _react2.default.createElement(
          'select',
          {
            ref: function ref(n) {
              return _this3.numberFilterComparator = n;
            },
            style: comparatorStyle,
            className: 'number-filter-comparator form-control ' + comparatorClassName,
            onChange: this.onChangeComparator,
            defaultValue: defaultValue ? defaultValue.comparator : ''
          },
          this.getComparatorOptions()
        ),
        options ? _react2.default.createElement(
          'select',
          {
            ref: function ref(n) {
              return _this3.numberFilter = n;
            },
            style: numberStyle,
            className: selectClass,
            onChange: this.onChangeNumberSet,
            defaultValue: defaultValue ? defaultValue.number : ''
          },
          this.getNumberOptions()
        ) : _react2.default.createElement('input', {
          ref: function ref(n) {
            return _this3.numberFilter = n;
          },
          type: 'number',
          style: numberStyle,
          className: 'number-filter-input form-control ' + numberClassName,
          placeholder: placeholder || 'Enter ' + column.text + '...',
          onChange: this.onChangeNumber,
          defaultValue: defaultValue ? defaultValue.number : ''
        })
      );
    }
  }]);

  return NumberFilter;
}(_react.Component);

NumberFilter.propTypes = {
  onFilter: _propTypes2.default.func.isRequired,
  column: _propTypes2.default.object.isRequired,
  options: _propTypes2.default.arrayOf(_propTypes2.default.number),
  defaultValue: _propTypes2.default.shape({
    number: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
    comparator: _propTypes2.default.oneOf([].concat(legalComparators, ['']))
  }),
  delay: _propTypes2.default.number,
  /* eslint consistent-return: 0 */
  comparators: function comparators(props, propName) {
    if (!props[propName]) {
      return;
    }
    for (var i = 0; i < props[propName].length; i += 1) {
      var comparatorIsValid = false;
      for (var j = 0; j < legalComparators.length; j += 1) {
        if (legalComparators[j] === props[propName][i] || props[propName][i] === '') {
          comparatorIsValid = true;
          break;
        }
      }
      if (!comparatorIsValid) {
        return new Error('Number comparator provided is not supported.\n          Use only ' + legalComparators);
      }
    }
  },
  placeholder: _propTypes2.default.string,
  withoutEmptyComparatorOption: _propTypes2.default.bool,
  withoutEmptyNumberOption: _propTypes2.default.bool,
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  comparatorStyle: _propTypes2.default.object,
  comparatorClassName: _propTypes2.default.string,
  numberStyle: _propTypes2.default.object,
  numberClassName: _propTypes2.default.string,
  getFilter: _propTypes2.default.func
};

NumberFilter.defaultProps = {
  delay: _const.FILTER_DELAY,
  options: undefined,
  defaultValue: {
    number: undefined,
    comparator: ''
  },
  withoutEmptyComparatorOption: false,
  withoutEmptyNumberOption: false,
  comparators: legalComparators,
  placeholder: undefined,
  style: undefined,
  className: '',
  comparatorStyle: undefined,
  comparatorClassName: '',
  numberStyle: undefined,
  numberClassName: ''
};

exports.default = NumberFilter;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _comparison = __webpack_require__(0);

var Comparator = _interopRequireWildcard(_comparison);

var _const = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint jsx-a11y/no-static-element-interactions: 0 */
/* eslint no-return-assign: 0 */
/* eslint prefer-template: 0 */


var legalComparators = [Comparator.EQ, Comparator.NE, Comparator.GT, Comparator.GE, Comparator.LT, Comparator.LE];

function dateParser(d) {
  return d.getFullYear() + '-' + ('0' + (d.getMonth() + 1)).slice(-2) + '-' + ('0' + d.getDate()).slice(-2);
}

var DateFilter = function (_Component) {
  _inherits(DateFilter, _Component);

  function DateFilter(props) {
    _classCallCheck(this, DateFilter);

    var _this = _possibleConstructorReturn(this, (DateFilter.__proto__ || Object.getPrototypeOf(DateFilter)).call(this, props));

    _this.timeout = null;
    _this.comparators = props.comparators || legalComparators;
    _this.applyFilter = _this.applyFilter.bind(_this);
    _this.onChangeDate = _this.onChangeDate.bind(_this);
    _this.onChangeComparator = _this.onChangeComparator.bind(_this);
    return _this;
  }

  _createClass(DateFilter, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var getFilter = this.props.getFilter;

      var comparator = this.dateFilterComparator.value;
      var date = this.inputDate.value;
      if (comparator && date) {
        this.applyFilter(date, comparator);
      }

      // export onFilter function to allow users to access
      if (getFilter) {
        getFilter(function (filterVal) {
          _this2.dateFilterComparator.value = filterVal.comparator;
          _this2.inputDate.value = dateParser(filterVal.date);

          _this2.applyFilter(filterVal.date, filterVal.comparator);
        });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.timeout) clearTimeout(this.timeout);
    }
  }, {
    key: 'onChangeDate',
    value: function onChangeDate(e) {
      var comparator = this.dateFilterComparator.value;
      var filterValue = e.target.value;
      this.applyFilter(filterValue, comparator);
    }
  }, {
    key: 'onChangeComparator',
    value: function onChangeComparator(e) {
      var value = this.inputDate.value;
      var comparator = e.target.value;
      this.applyFilter(value, comparator);
    }
  }, {
    key: 'getComparatorOptions',
    value: function getComparatorOptions() {
      var optionTags = [];
      var withoutEmptyComparatorOption = this.props.withoutEmptyComparatorOption;

      if (!withoutEmptyComparatorOption) {
        optionTags.push(_react2.default.createElement('option', { key: '-1' }));
      }
      for (var i = 0; i < this.comparators.length; i += 1) {
        optionTags.push(_react2.default.createElement(
          'option',
          { key: i, value: this.comparators[i] },
          this.comparators[i]
        ));
      }
      return optionTags;
    }
  }, {
    key: 'getDefaultDate',
    value: function getDefaultDate() {
      var defaultDate = '';
      var defaultValue = this.props.defaultValue;

      if (defaultValue && defaultValue.date) {
        // Set the appropriate format for the input type=date, i.e. "YYYY-MM-DD"
        defaultDate = dateParser(new Date(defaultValue.date));
      }
      return defaultDate;
    }
  }, {
    key: 'applyFilter',
    value: function applyFilter(value, comparator) {
      // if (!comparator || !value) {
      //  return;
      // }
      var _props = this.props,
          column = _props.column,
          onFilter = _props.onFilter,
          delay = _props.delay;

      var execute = function execute() {
        // Incoming value should always be a string, and the defaultDate
        // above is implemented as an empty string, so we can just check for that.
        // instead of parsing an invalid Date. The filter function will interpret
        // null as an empty date field
        var date = value === '' ? null : new Date(value);
        onFilter(column, _const.FILTER_TYPE.DATE)({ date: date, comparator: comparator });
      };
      if (delay) {
        this.timeout = setTimeout(function () {
          execute();
        }, delay);
      } else {
        execute();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props2 = this.props,
          placeholder = _props2.placeholder,
          text = _props2.column.text,
          style = _props2.style,
          comparatorStyle = _props2.comparatorStyle,
          dateStyle = _props2.dateStyle,
          className = _props2.className,
          comparatorClassName = _props2.comparatorClassName,
          dateClassName = _props2.dateClassName,
          defaultValue = _props2.defaultValue;


      return _react2.default.createElement(
        'div',
        {
          onClick: function onClick(e) {
            return e.stopPropagation();
          },
          className: 'filter date-filter ' + className,
          style: style
        },
        _react2.default.createElement(
          'select',
          {
            ref: function ref(n) {
              return _this3.dateFilterComparator = n;
            },
            style: comparatorStyle,
            className: 'date-filter-comparator form-control ' + comparatorClassName,
            onChange: this.onChangeComparator,
            defaultValue: defaultValue ? defaultValue.comparator : ''
          },
          this.getComparatorOptions()
        ),
        _react2.default.createElement('input', {
          ref: function ref(n) {
            return _this3.inputDate = n;
          },
          className: 'filter date-filter-input form-control ' + dateClassName,
          style: dateStyle,
          type: 'date',
          onChange: this.onChangeDate,
          placeholder: placeholder || 'Enter ' + text + '...',
          defaultValue: this.getDefaultDate()
        })
      );
    }
  }]);

  return DateFilter;
}(_react.Component);

DateFilter.propTypes = {
  onFilter: _propTypes.PropTypes.func.isRequired,
  column: _propTypes.PropTypes.object.isRequired,
  delay: _propTypes.PropTypes.number,
  defaultValue: _propTypes.PropTypes.shape({
    date: _propTypes.PropTypes.oneOfType([_propTypes.PropTypes.object]),
    comparator: _propTypes.PropTypes.oneOf([].concat(legalComparators, ['']))
  }),
  /* eslint consistent-return: 0 */
  comparators: function comparators(props, propName) {
    if (!props[propName]) {
      return;
    }
    for (var i = 0; i < props[propName].length; i += 1) {
      var comparatorIsValid = false;
      for (var j = 0; j < legalComparators.length; j += 1) {
        if (legalComparators[j] === props[propName][i] || props[propName][i] === '') {
          comparatorIsValid = true;
          break;
        }
      }
      if (!comparatorIsValid) {
        return new Error('Date comparator provided is not supported.\n          Use only ' + legalComparators);
      }
    }
  },
  placeholder: _propTypes.PropTypes.string,
  withoutEmptyComparatorOption: _propTypes.PropTypes.bool,
  style: _propTypes.PropTypes.object,
  comparatorStyle: _propTypes.PropTypes.object,
  dateStyle: _propTypes.PropTypes.object,
  className: _propTypes.PropTypes.string,
  comparatorClassName: _propTypes.PropTypes.string,
  dateClassName: _propTypes.PropTypes.string,
  getFilter: _propTypes.PropTypes.func
};

DateFilter.defaultProps = {
  delay: 0,
  defaultValue: {
    date: undefined,
    comparator: ''
  },
  withoutEmptyComparatorOption: false,
  comparators: legalComparators,
  placeholder: undefined,
  style: undefined,
  className: '',
  comparatorStyle: undefined,
  comparatorClassName: '',
  dateStyle: undefined,
  dateClassName: ''
};

exports.default = DateFilter;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _filter = __webpack_require__(15);

var _comparison = __webpack_require__(0);

var _const = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-param-reassign: 0 */

exports.default = function (Base, _ref) {
  var _class, _temp;

  var _ = _ref._,
      remoteResolver = _ref.remoteResolver;
  return _temp = _class = function (_remoteResolver) {
    _inherits(FilterWrapper, _remoteResolver);

    function FilterWrapper(props) {
      _classCallCheck(this, FilterWrapper);

      var _this = _possibleConstructorReturn(this, (FilterWrapper.__proto__ || Object.getPrototypeOf(FilterWrapper)).call(this, props));

      _this.state = { currFilters: {}, isDataChanged: props.isDataChanged || false };
      _this.onFilter = _this.onFilter.bind(_this);
      _this.onExternalFilter = _this.onExternalFilter.bind(_this);
      return _this;
    }

    _createClass(FilterWrapper, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(_ref2) {
        var isDataChanged = _ref2.isDataChanged,
            store = _ref2.store,
            columns = _ref2.columns;

        // consider to use lodash.isEqual
        var isRemoteFilter = this.isRemoteFiltering() || this.isRemotePagination();
        if (isRemoteFilter || JSON.stringify(this.state.currFilters) !== JSON.stringify(store.filters)) {
          // I think this condition only isRemoteFilter is enough
          store.filteredData = store.getAllData();
          this.setState(function () {
            return { isDataChanged: true, currFilters: store.filters };
          });
        } else {
          if (Object.keys(this.state.currFilters).length > 0) {
            store.filteredData = (0, _filter.filters)(store, columns, _)(this.state.currFilters);
          }
          this.setState(function () {
            return { isDataChanged: isDataChanged };
          });
        }
      }

      /**
       * filter the table like below:
       * onFilter(column, filterType)(filterVal)
       * @param {Object} column
       * @param {String} filterType
       * @param {String} filterVal - user input for filtering.
       */

    }, {
      key: 'onFilter',
      value: function onFilter(column, filterType) {
        var _this2 = this;

        return function (filterVal) {
          var _props = _this2.props,
              store = _props.store,
              columns = _props.columns;
          // watch out here if migration to context API, #334

          var currFilters = Object.assign({}, store.filters);
          var dataField = column.dataField,
              filter = column.filter;


          var needClearFilters = !_.isDefined(filterVal) || filterVal === '' || filterVal.length === 0;

          if (needClearFilters) {
            delete currFilters[dataField];
          } else {
            // select default comparator is EQ, others are LIKE
            var _filter$props = filter.props,
                _filter$props$compara = _filter$props.comparator,
                comparator = _filter$props$compara === undefined ? filterType === _const.FILTER_TYPE.SELECT || filterType === _const.FILTER_TYPE.MULTISELECT ? _comparison.EQ : _comparison.LIKE : _filter$props$compara,
                _filter$props$caseSen = _filter$props.caseSensitive,
                caseSensitive = _filter$props$caseSen === undefined ? false : _filter$props$caseSen;

            currFilters[dataField] = { filterVal: filterVal, filterType: filterType, comparator: comparator, caseSensitive: caseSensitive };
          }

          store.filters = currFilters;

          if (_this2.isRemoteFiltering() || _this2.isRemotePagination()) {
            _this2.handleRemoteFilterChange();
            // when remote filtering is enable, dont set currFilters state
            // in the componentWillReceiveProps,
            // it's the key point that we can know the filter is changed
            return;
          }

          store.filteredData = (0, _filter.filters)(store, columns, _)(currFilters);
          _this2.setState(function () {
            return { currFilters: currFilters, isDataChanged: true };
          });
        };
      }
    }, {
      key: 'onExternalFilter',
      value: function onExternalFilter(column, filterType) {
        var _this3 = this;

        return function (value) {
          _this3.onFilter(column, filterType)(value);
        };
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(Base, _extends({}, this.props, {
          data: this.props.store.data,
          onFilter: this.onFilter,
          onExternalFilter: this.onExternalFilter,
          isDataChanged: this.state.isDataChanged
        }));
      }
    }]);

    return FilterWrapper;
  }(remoteResolver(_react.Component)), _class.propTypes = {
    store: _propTypes2.default.object.isRequired,
    columns: _propTypes2.default.array.isRequired
  }, _temp;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filters = exports.filterFactory = exports.filterByArray = exports.filterByDate = exports.filterByNumber = exports.filterByText = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* eslint eqeqeq: 0 */
/* eslint no-console: 0 */


var _const = __webpack_require__(1);

var _comparison = __webpack_require__(0);

var filterByText = exports.filterByText = function filterByText(_) {
  return function (data, dataField, _ref, customFilterValue) {
    var _ref$filterVal = _ref.filterVal,
        userInput = _ref$filterVal === undefined ? '' : _ref$filterVal,
        _ref$comparator = _ref.comparator,
        comparator = _ref$comparator === undefined ? _comparison.LIKE : _ref$comparator,
        caseSensitive = _ref.caseSensitive;

    // make sure filter value to be a string
    var filterVal = userInput.toString();

    return data.filter(function (row) {
      var cell = _.get(row, dataField);
      if (customFilterValue) {
        cell = customFilterValue(cell, row);
      }
      var cellStr = _.isDefined(cell) ? cell.toString() : '';
      if (comparator === _comparison.EQ) {
        return cellStr === filterVal;
      }
      if (caseSensitive) {
        return cellStr.includes(filterVal);
      }

      return cellStr.toLocaleUpperCase().indexOf(filterVal.toLocaleUpperCase()) !== -1;
    });
  };
};

var filterByNumber = exports.filterByNumber = function filterByNumber(_) {
  return function (data, dataField, _ref2, customFilterValue) {
    var _ref2$filterVal = _ref2.filterVal,
        comparator = _ref2$filterVal.comparator,
        number = _ref2$filterVal.number;
    return data.filter(function (row) {
      if (number === '' || !comparator) return true;
      var valid = true;
      var cell = _.get(row, dataField);
      if (customFilterValue) {
        cell = customFilterValue(cell, row);
      }

      switch (comparator) {
        case _comparison.EQ:
          {
            if (cell != number) {
              valid = false;
            }
            break;
          }
        case _comparison.GT:
          {
            if (cell <= number) {
              valid = false;
            }
            break;
          }
        case _comparison.GE:
          {
            if (cell < number) {
              valid = false;
            }
            break;
          }
        case _comparison.LT:
          {
            if (cell >= number) {
              valid = false;
            }
            break;
          }
        case _comparison.LE:
          {
            if (cell > number) {
              valid = false;
            }
            break;
          }
        case _comparison.NE:
          {
            if (cell == number) {
              valid = false;
            }
            break;
          }
        default:
          {
            console.error('Number comparator provided is not supported');
            break;
          }
      }
      return valid;
    });
  };
};

var filterByDate = exports.filterByDate = function filterByDate(_) {
  return function (data, dataField, _ref3, customFilterValue) {
    var _ref3$filterVal = _ref3.filterVal,
        comparator = _ref3$filterVal.comparator,
        date = _ref3$filterVal.date;

    if (!date || !comparator) return data;
    var filterDate = date.getDate();
    var filterMonth = date.getMonth();
    var filterYear = date.getFullYear();

    return data.filter(function (row) {
      var valid = true;
      var cell = _.get(row, dataField);

      if (customFilterValue) {
        cell = customFilterValue(cell, row);
      }

      if ((typeof cell === 'undefined' ? 'undefined' : _typeof(cell)) !== 'object') {
        cell = new Date(cell);
      }

      var targetDate = cell.getDate();
      var targetMonth = cell.getMonth();
      var targetYear = cell.getFullYear();

      switch (comparator) {
        case _comparison.EQ:
          {
            if (filterDate !== targetDate || filterMonth !== targetMonth || filterYear !== targetYear) {
              valid = false;
            }
            break;
          }
        case _comparison.GT:
          {
            if (cell <= date) {
              valid = false;
            }
            break;
          }
        case _comparison.GE:
          {
            if (targetYear < filterYear) {
              valid = false;
            } else if (targetYear === filterYear && targetMonth < filterMonth) {
              valid = false;
            } else if (targetYear === filterYear && targetMonth === filterMonth && targetDate < filterDate) {
              valid = false;
            }
            break;
          }
        case _comparison.LT:
          {
            if (cell >= date) {
              valid = false;
            }
            break;
          }
        case _comparison.LE:
          {
            if (targetYear > filterYear) {
              valid = false;
            } else if (targetYear === filterYear && targetMonth > filterMonth) {
              valid = false;
            } else if (targetYear === filterYear && targetMonth === filterMonth && targetDate > filterDate) {
              valid = false;
            }
            break;
          }
        case _comparison.NE:
          {
            if (filterDate === targetDate && filterMonth === targetMonth && filterYear === targetYear) {
              valid = false;
            }
            break;
          }
        default:
          {
            console.error('Date comparator provided is not supported');
            break;
          }
      }
      return valid;
    });
  };
};

var filterByArray = exports.filterByArray = function filterByArray(_) {
  return function (data, dataField, _ref4) {
    var filterVal = _ref4.filterVal,
        comparator = _ref4.comparator;

    if (filterVal.length === 0) return data;
    var refinedFilterVal = filterVal.filter(function (x) {
      return _.isDefined(x);
    }).map(function (x) {
      return x.toString();
    });
    return data.filter(function (row) {
      var cell = _.get(row, dataField);
      var cellStr = _.isDefined(cell) ? cell.toString() : '';
      if (comparator === _comparison.EQ) {
        return refinedFilterVal.indexOf(cellStr) !== -1;
      }
      cellStr = cellStr.toLocaleUpperCase();
      return refinedFilterVal.some(function (item) {
        return cellStr.indexOf(item.toLocaleUpperCase()) !== -1;
      });
    });
  };
};

var filterFactory = exports.filterFactory = function filterFactory(_) {
  return function (filterType) {
    var filterFn = void 0;
    switch (filterType) {
      case _const.FILTER_TYPE.TEXT:
      case _const.FILTER_TYPE.SELECT:
        filterFn = filterByText(_);
        break;
      case _const.FILTER_TYPE.MULTISELECT:
        filterFn = filterByArray(_);
        break;
      case _const.FILTER_TYPE.NUMBER:
        filterFn = filterByNumber(_);
        break;
      case _const.FILTER_TYPE.DATE:
        filterFn = filterByDate(_);
        break;
      default:
        filterFn = filterByText(_);
    }
    return filterFn;
  };
};

var filters = exports.filters = function filters(store, columns, _) {
  return function (currFilters) {
    var factory = filterFactory(_);
    var result = store.getAllData();
    var filterFn = void 0;
    Object.keys(currFilters).forEach(function (dataField) {
      var filterObj = currFilters[dataField];
      filterFn = factory(filterObj.filterType);
      var filterValue = void 0;
      for (var i = 0; i < columns.length; i += 1) {
        if (columns[i].dataField === dataField) {
          filterValue = columns[i].filterValue;
          break;
        }
      }
      result = filterFn(result, dataField, filterObj, filterValue);
    });
    return result;
  };
};

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBhMDIzNTU5OGMyMTcyYWY5MWVkYSIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29tcGFyaXNvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29uc3QuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJjb21tb25qc1wiOlwicmVhY3RcIixcImFtZFwiOlwicmVhY3RcIn0iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIvc3JjL2NvbXBvbmVudHMvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIvc3JjL2NvbXBvbmVudHMvc2VsZWN0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy9jb21wb25lbnRzL211bHRpc2VsZWN0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy9jb21wb25lbnRzL251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29tcG9uZW50cy9kYXRlLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy93cmFwcGVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy9maWx0ZXIuanMiXSwibmFtZXMiOlsiTElLRSIsIkVRIiwiTkUiLCJHVCIsIkdFIiwiTFQiLCJMRSIsIkZJTFRFUl9UWVBFIiwiVEVYVCIsIlNFTEVDVCIsIk1VTFRJU0VMRUNUIiwiTlVNQkVSIiwiREFURSIsIkZJTFRFUl9ERUxBWSIsIkNvbXBhcmlzb24iLCJvcHRpb25zIiwid3JhcHBlckZhY3RvcnkiLCJGSUxURVJfVFlQRVMiLCJDb21wYXJhdG9yIiwidGV4dEZpbHRlciIsInByb3BzIiwiRmlsdGVyIiwic2VsZWN0RmlsdGVyIiwibXVsdGlTZWxlY3RGaWx0ZXIiLCJudW1iZXJGaWx0ZXIiLCJkYXRlRmlsdGVyIiwiY3VzdG9tRmlsdGVyIiwiVGV4dEZpbHRlciIsImZpbHRlciIsImJpbmQiLCJoYW5kbGVDbGljayIsInRpbWVvdXQiLCJzdGF0ZSIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwib25GaWx0ZXIiLCJnZXRGaWx0ZXIiLCJjb2x1bW4iLCJpbnB1dCIsImZpbHRlclZhbCIsInNldFN0YXRlIiwibmV4dFByb3BzIiwiYXBwbHlGaWx0ZXIiLCJjbGVhblRpbWVyIiwiZSIsInN0b3BQcm9wYWdhdGlvbiIsImZpbHRlclZhbHVlIiwidGFyZ2V0Iiwic2V0VGltZW91dCIsImRlbGF5IiwiY2xlYXJUaW1lb3V0IiwiZmlsdGVyVGV4dCIsIm9uQ2xpY2siLCJwbGFjZWhvbGRlciIsInRleHQiLCJzdHlsZSIsImNsYXNzTmFtZSIsImNhc2VTZW5zaXRpdmUiLCJyZXN0IiwibiIsInByb3BUeXBlcyIsImZ1bmMiLCJpc1JlcXVpcmVkIiwib2JqZWN0IiwiY29tcGFyYXRvciIsIm9uZU9mIiwic3RyaW5nIiwibnVtYmVyIiwiYm9vbCIsImRlZmF1bHRQcm9wcyIsIm9wdGlvbnNFcXVhbHMiLCJjdXJyT3B0cyIsInByZXZPcHRzIiwia2V5cyIsIk9iamVjdCIsImkiLCJsZW5ndGgiLCJTZWxlY3RGaWx0ZXIiLCJpc1NlbGVjdGVkIiwidW5kZWZpbmVkIiwic2VsZWN0SW5wdXQiLCJwcmV2UHJvcHMiLCJuZWVkRmlsdGVyIiwib3B0aW9uVGFncyIsIndpdGhvdXRFbXB0eU9wdGlvbiIsInB1c2giLCJmb3JFYWNoIiwia2V5Iiwic2VsZWN0Q2xhc3MiLCJnZXRPcHRpb25zIiwiYW55IiwiZ2V0U2VsZWN0aW9ucyIsIkFycmF5IiwiZnJvbSIsImNvbnRhaW5lciIsInNlbGVjdGVkT3B0aW9ucyIsIm1hcCIsIml0ZW0iLCJNdWx0aVNlbGVjdEZpbHRlciIsImFycmF5IiwibGVnYWxDb21wYXJhdG9ycyIsIk51bWJlckZpbHRlciIsImNvbXBhcmF0b3JzIiwiaW5kZXhPZiIsIm9uQ2hhbmdlTnVtYmVyIiwib25DaGFuZ2VOdW1iZXJTZXQiLCJvbkNoYW5nZUNvbXBhcmF0b3IiLCJudW1iZXJGaWx0ZXJDb21wYXJhdG9yIiwid2l0aG91dEVtcHR5Q29tcGFyYXRvck9wdGlvbiIsIndpdGhvdXRFbXB0eU51bWJlck9wdGlvbiIsImZpbHRlck9iaiIsIm51bWJlclN0eWxlIiwibnVtYmVyQ2xhc3NOYW1lIiwiY29tcGFyYXRvclN0eWxlIiwiY29tcGFyYXRvckNsYXNzTmFtZSIsImdldENvbXBhcmF0b3JPcHRpb25zIiwiZ2V0TnVtYmVyT3B0aW9ucyIsImFycmF5T2YiLCJzaGFwZSIsIm9uZU9mVHlwZSIsInByb3BOYW1lIiwiY29tcGFyYXRvcklzVmFsaWQiLCJqIiwiRXJyb3IiLCJkYXRlUGFyc2VyIiwiZCIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJzbGljZSIsImdldERhdGUiLCJEYXRlRmlsdGVyIiwib25DaGFuZ2VEYXRlIiwiZGF0ZUZpbHRlckNvbXBhcmF0b3IiLCJkYXRlIiwiaW5wdXREYXRlIiwiZGVmYXVsdERhdGUiLCJEYXRlIiwiZXhlY3V0ZSIsImRhdGVTdHlsZSIsImRhdGVDbGFzc05hbWUiLCJnZXREZWZhdWx0RGF0ZSIsIkJhc2UiLCJfIiwicmVtb3RlUmVzb2x2ZXIiLCJjdXJyRmlsdGVycyIsImlzRGF0YUNoYW5nZWQiLCJvbkV4dGVybmFsRmlsdGVyIiwic3RvcmUiLCJjb2x1bW5zIiwiaXNSZW1vdGVGaWx0ZXIiLCJpc1JlbW90ZUZpbHRlcmluZyIsImlzUmVtb3RlUGFnaW5hdGlvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJmaWx0ZXJzIiwiZmlsdGVyZWREYXRhIiwiZ2V0QWxsRGF0YSIsImZpbHRlclR5cGUiLCJhc3NpZ24iLCJkYXRhRmllbGQiLCJuZWVkQ2xlYXJGaWx0ZXJzIiwiaXNEZWZpbmVkIiwiaGFuZGxlUmVtb3RlRmlsdGVyQ2hhbmdlIiwiZGF0YSIsImZpbHRlckJ5VGV4dCIsImN1c3RvbUZpbHRlclZhbHVlIiwidXNlcklucHV0IiwidG9TdHJpbmciLCJyb3ciLCJjZWxsIiwiZ2V0IiwiY2VsbFN0ciIsImluY2x1ZGVzIiwidG9Mb2NhbGVVcHBlckNhc2UiLCJmaWx0ZXJCeU51bWJlciIsInZhbGlkIiwiY29uc29sZSIsImVycm9yIiwiZmlsdGVyQnlEYXRlIiwiZmlsdGVyRGF0ZSIsImZpbHRlck1vbnRoIiwiZmlsdGVyWWVhciIsInRhcmdldERhdGUiLCJ0YXJnZXRNb250aCIsInRhcmdldFllYXIiLCJmaWx0ZXJCeUFycmF5IiwicmVmaW5lZEZpbHRlclZhbCIsIngiLCJzb21lIiwiZmlsdGVyRmFjdG9yeSIsImZpbHRlckZuIiwiZmFjdG9yeSIs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QUFSLEVBQVc3QixXQUF6QjtBQUNBO0FBQ0Q7QUFDRjtBQUNEa0osZUFBU0YsU0FBU0UsTUFBVCxFQUFpQmpDLFNBQWpCLEVBQTRCakQsU0FBNUIsRUFBdUNoRSxXQUF2QyxDQUFUO0FBQ0QsS0FYRDtBQVlBLFdBQU9rSixNQUFQO0FBQ0QsR0FqQnNCO0FBQUEsQ0FBaEIsQyIsImZpbGUiOiJyZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9kaXN0L3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUmVhY3RCb290c3RyYXBUYWJsZTJGaWx0ZXJcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiUmVhY3RCb290c3RyYXBUYWJsZTJGaWx0ZXJcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA0KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBhMDIzNTU5OGMyMTcyYWY5MWVkYSIsImV4cG9ydCBjb25zdCBMSUtFID0gJ0xJS0UnO1xuZXhwb3J0IGNvbnN0IEVRID0gJz0nO1xuZXhwb3J0IGNvbnN0IE5FID0gJyE9JztcbmV4cG9ydCBjb25zdCBHVCA9ICc+JztcbmV4cG9ydCBjb25zdCBHRSA9ICc+PSc7XG5leHBvcnQgY29uc3QgTFQgPSAnPCc7XG5leHBvcnQgY29uc3QgTEUgPSAnPD0nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIvc3JjL2NvbXBhcmlzb24uanMiLCJleHBvcnQgY29uc3QgRklMVEVSX1RZUEUgPSB7XG4gIFRFWFQ6ICdURVhUJyxcbiAgU0VMRUNUOiAnU0VMRUNUJyxcbiAgTVVMVElTRUxFQ1Q6ICdNVUxUSVNFTEVDVCcsXG4gIE5VTUJFUjogJ05VTUJFUicsXG4gIERBVEU6ICdEQVRFJ1xufTtcblxuZXhwb3J0IGNvbnN0IEZJTFRFUl9ERUxBWSA9IDUwMDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy9jb25zdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifVxuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IFRleHRGaWx0ZXIgZnJvbSAnLi9zcmMvY29tcG9uZW50cy90ZXh0JztcbmltcG9ydCBTZWxlY3RGaWx0ZXIgZnJvbSAnLi9zcmMvY29tcG9uZW50cy9zZWxlY3QnO1xuaW1wb3J0IE11bHRpU2VsZWN0RmlsdGVyIGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbXVsdGlzZWxlY3QnO1xuaW1wb3J0IE51bWJlckZpbHRlciBmcm9tICcuL3NyYy9jb21wb25lbnRzL251bWJlcic7XG5pbXBvcnQgRGF0ZUZpbHRlciBmcm9tICcuL3NyYy9jb21wb25lbnRzL2RhdGUnO1xuaW1wb3J0IHdyYXBwZXJGYWN0b3J5IGZyb20gJy4vc3JjL3dyYXBwZXInO1xuaW1wb3J0ICogYXMgQ29tcGFyaXNvbiBmcm9tICcuL3NyYy9jb21wYXJpc29uJztcbmltcG9ydCB7IEZJTFRFUl9UWVBFIH0gZnJvbSAnLi9zcmMvY29uc3QnO1xuXG5leHBvcnQgZGVmYXVsdCAob3B0aW9ucyA9IHt9KSA9PiAoe1xuICB3cmFwcGVyRmFjdG9yeSxcbiAgb3B0aW9uc1xufSk7XG5cbmV4cG9ydCBjb25zdCBGSUxURVJfVFlQRVMgPSBGSUxURVJfVFlQRTtcblxuZXhwb3J0IGNvbnN0IENvbXBhcmF0b3IgPSBDb21wYXJpc29uO1xuXG5leHBvcnQgY29uc3QgdGV4dEZpbHRlciA9IChwcm9wcyA9IHt9KSA9PiAoe1xuICBGaWx0ZXI6IFRleHRGaWx0ZXIsXG4gIHByb3BzXG59KTtcblxuZXhwb3J0IGNvbnN0IHNlbGVjdEZpbHRlciA9IChwcm9wcyA9IHt9KSA9PiAoe1xuICBGaWx0ZXI6IFNlbGVjdEZpbHRlcixcbiAgcHJvcHNcbn0pO1xuXG5leHBvcnQgY29uc3QgbXVsdGlTZWxlY3RGaWx0ZXIgPSAocHJvcHMgPSB7fSkgPT4gKHtcbiAgRmlsdGVyOiBNdWx0aVNlbGVjdEZpbHRlcixcbiAgcHJvcHNcbn0pO1xuXG5leHBvcnQgY29uc3QgbnVtYmVyRmlsdGVyID0gKHByb3BzID0ge30pID0+ICh7XG4gIEZpbHRlcjogTnVtYmVyRmlsdGVyLFxuICBwcm9wc1xufSk7XG5cbmV4cG9ydCBjb25zdCBkYXRlRmlsdGVyID0gKHByb3BzID0ge30pID0+ICh7XG4gIEZpbHRlcjogRGF0ZUZpbHRlcixcbiAgcHJvcHNcbn0pO1xuXG5leHBvcnQgY29uc3QgY3VzdG9tRmlsdGVyID0gKHByb3BzID0ge30pID0+ICh7XG4gIHByb3BzXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL2luZGV4LmpzIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbi8qIGVzbGludCBuby1yZXR1cm4tYXNzaWduOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJvcFR5cGVzIH0gZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCB7IExJS0UsIEVRIH0gZnJvbSAnLi4vY29tcGFyaXNvbic7XG5pbXBvcnQgeyBGSUxURVJfVFlQRSwgRklMVEVSX0RFTEFZIH0gZnJvbSAnLi4vY29uc3QnO1xuXG5jbGFzcyBUZXh0RmlsdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5maWx0ZXIgPSB0aGlzLmZpbHRlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IHByb3BzLmRlZmF1bHRWYWx1ZVxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IG9uRmlsdGVyLCBnZXRGaWx0ZXIsIGNvbHVtbiB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmlucHV0LnZhbHVlO1xuXG4gICAgaWYgKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgb25GaWx0ZXIodGhpcy5wcm9wcy5jb2x1bW4sIEZJTFRFUl9UWVBFLlRFWFQpKGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gZXhwb3J0IG9uRmlsdGVyIGZ1bmN0aW9uIHRvIGFsbG93IHVzZXJzIHRvIGFjY2Vzc1xuICAgIGlmIChnZXRGaWx0ZXIpIHtcbiAgICAgIGdldEZpbHRlcigoZmlsdGVyVmFsKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgdmFsdWU6IGZpbHRlclZhbCB9KSk7XG4gICAgICAgIG9uRmlsdGVyKGNvbHVtbiwgRklMVEVSX1RZUEUuVEVYVCkoZmlsdGVyVmFsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5kZWZhdWx0VmFsdWUgIT09IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlKSB7XG4gICAgICB0aGlzLmFwcGx5RmlsdGVyKG5leHRQcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2xlYW5UaW1lcigpO1xuICB9XG5cbiAgZmlsdGVyKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuY2xlYW5UaW1lcigpO1xuICAgIGNvbnN0IGZpbHRlclZhbHVlID0gZS50YXJnZXQudmFsdWU7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyB2YWx1ZTogZmlsdGVyVmFsdWUgfSkpO1xuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vbkZpbHRlcih0aGlzLnByb3BzLmNvbHVtbiwgRklMVEVSX1RZUEUuVEVYVCkoZmlsdGVyVmFsdWUpO1xuICAgIH0sIHRoaXMucHJvcHMuZGVsYXkpO1xuICB9XG5cbiAgY2xlYW5UaW1lcigpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICBjbGVhbkZpbHRlcmVkKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyB2YWx1ZSB9KSk7XG4gICAgdGhpcy5wcm9wcy5vbkZpbHRlcih0aGlzLnByb3BzLmNvbHVtbiwgRklMVEVSX1RZUEUuVEVYVCkodmFsdWUpO1xuICB9XG5cbiAgYXBwbHlGaWx0ZXIoZmlsdGVyVGV4dCkge1xuICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgdmFsdWU6IGZpbHRlclRleHQgfSkpO1xuICAgIHRoaXMucHJvcHMub25GaWx0ZXIodGhpcy5wcm9wcy5jb2x1bW4sIEZJTFRFUl9UWVBFLlRFWFQpKGZpbHRlclRleHQpO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2soZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKHRoaXMucHJvcHMub25DbGljaykge1xuICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrKGUpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIGNvbHVtbjogeyB0ZXh0IH0sXG4gICAgICBzdHlsZSxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIG9uRmlsdGVyLFxuICAgICAgY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgIGdldEZpbHRlcixcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIHN0b3BQcm9wYWdhdGlvbiBmb3Igb25DbGljayBldmVudCBpcyB0cnkgdG8gcHJldmVudCBzb3J0IHdhcyB0cmlnZ2VyZWQuXG4gICAgcmV0dXJuIChcbiAgICAgIDxpbnB1dFxuICAgICAgICB7IC4uLnJlc3QgfVxuICAgICAgICByZWY9eyBuID0+IHRoaXMuaW5wdXQgPSBuIH1cbiAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICBjbGFzc05hbWU9eyBgZmlsdGVyIHRleHQtZmlsdGVyIGZvcm0tY29udHJvbCAke2NsYXNzTmFtZX1gIH1cbiAgICAgICAgc3R5bGU9eyBzdHlsZSB9XG4gICAgICAgIG9uQ2hhbmdlPXsgdGhpcy5maWx0ZXIgfVxuICAgICAgICBvbkNsaWNrPXsgdGhpcy5oYW5kbGVDbGljayB9XG4gICAgICAgIHBsYWNlaG9sZGVyPXsgcGxhY2Vob2xkZXIgfHwgYEVudGVyICR7dGV4dH0uLi5gIH1cbiAgICAgICAgdmFsdWU9eyB0aGlzLnN0YXRlLnZhbHVlIH1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxufVxuXG5UZXh0RmlsdGVyLnByb3BUeXBlcyA9IHtcbiAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGNvbHVtbjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBjb21wYXJhdG9yOiBQcm9wVHlwZXMub25lT2YoW0xJS0UsIEVRXSksXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZGVsYXk6IFByb3BUeXBlcy5udW1iZXIsXG4gIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjYXNlU2Vuc2l0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ2V0RmlsdGVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuVGV4dEZpbHRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGRlbGF5OiBGSUxURVJfREVMQVksXG4gIGRlZmF1bHRWYWx1ZTogJycsXG4gIGNhc2VTZW5zaXRpdmU6IGZhbHNlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFRleHRGaWx0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29tcG9uZW50cy90ZXh0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuLyogZXNsaW50IG5vLXJldHVybi1hc3NpZ246IDAgKi9cbi8qIGVzbGludCByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlczogMCAqL1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBMSUtFLCBFUSB9IGZyb20gJy4uL2NvbXBhcmlzb24nO1xuaW1wb3J0IHsgRklMVEVSX1RZUEUgfSBmcm9tICcuLi9jb25zdCc7XG5cbmZ1bmN0aW9uIG9wdGlvbnNFcXVhbHMoY3Vyck9wdHMsIHByZXZPcHRzKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjdXJyT3B0cyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChjdXJyT3B0c1trZXlzW2ldXSAhPT0gcHJldk9wdHNba2V5c1tpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGN1cnJPcHRzKS5sZW5ndGggPT09IE9iamVjdC5rZXlzKHByZXZPcHRzKS5sZW5ndGg7XG59XG5cbmNsYXNzIFNlbGVjdEZpbHRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuZmlsdGVyID0gdGhpcy5maWx0ZXIuYmluZCh0aGlzKTtcbiAgICBjb25zdCBpc1NlbGVjdGVkID0gcHJvcHMub3B0aW9uc1twcm9wcy5kZWZhdWx0VmFsdWVdICE9PSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGF0ZSA9IHsgaXNTZWxlY3RlZCB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBjb2x1bW4sIG9uRmlsdGVyLCBnZXRGaWx0ZXIgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc2VsZWN0SW5wdXQudmFsdWU7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnJykge1xuICAgICAgb25GaWx0ZXIoY29sdW1uLCBGSUxURVJfVFlQRS5TRUxFQ1QpKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBleHBvcnQgb25GaWx0ZXIgZnVuY3Rpb24gdG8gYWxsb3cgdXNlcnMgdG8gYWNjZXNzXG4gICAgaWYgKGdldEZpbHRlcikge1xuICAgICAgZ2V0RmlsdGVyKChmaWx0ZXJWYWwpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBpc1NlbGVjdGVkOiBmaWx0ZXJWYWwgIT09ICcnIH0pKTtcbiAgICAgICAgdGhpcy5zZWxlY3RJbnB1dC52YWx1ZSA9IGZpbHRlclZhbDtcblxuICAgICAgICBvbkZpbHRlcihjb2x1bW4sIEZJTFRFUl9UWVBFLlNFTEVDVCkoZmlsdGVyVmFsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBsZXQgbmVlZEZpbHRlciA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gcHJldlByb3BzLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgbmVlZEZpbHRlciA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghb3B0aW9uc0VxdWFscyh0aGlzLnByb3BzLm9wdGlvbnMsIHByZXZQcm9wcy5vcHRpb25zKSkge1xuICAgICAgbmVlZEZpbHRlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChuZWVkRmlsdGVyKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc2VsZWN0SW5wdXQudmFsdWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkZpbHRlcih0aGlzLnByb3BzLmNvbHVtbiwgRklMVEVSX1RZUEUuU0VMRUNUKSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25UYWdzID0gW107XG4gICAgY29uc3QgeyBvcHRpb25zLCBwbGFjZWhvbGRlciwgY29sdW1uLCB3aXRob3V0RW1wdHlPcHRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCF3aXRob3V0RW1wdHlPcHRpb24pIHtcbiAgICAgIG9wdGlvblRhZ3MucHVzaCgoXG4gICAgICAgIDxvcHRpb24ga2V5PVwiLTFcIiB2YWx1ZT1cIlwiPnsgcGxhY2Vob2xkZXIgfHwgYFNlbGVjdCAke2NvbHVtbi50ZXh0fS4uLmAgfTwvb3B0aW9uPlxuICAgICAgKSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goa2V5ID0+XG4gICAgICBvcHRpb25UYWdzLnB1c2goPG9wdGlvbiBrZXk9eyBrZXkgfSB2YWx1ZT17IGtleSB9Pnsgb3B0aW9uc1trZXldIH08L29wdGlvbj4pXG4gICAgKTtcbiAgICByZXR1cm4gb3B0aW9uVGFncztcbiAgfVxuXG4gIGNsZWFuRmlsdGVyZWQoKSB7XG4gICAgY29uc3QgdmFsdWUgPSAodGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkgPyB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSA6ICcnO1xuICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgaXNTZWxlY3RlZDogdmFsdWUgIT09ICcnIH0pKTtcbiAgICB0aGlzLnNlbGVjdElucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5wcm9wcy5vbkZpbHRlcih0aGlzLnByb3BzLmNvbHVtbiwgRklMVEVSX1RZUEUuU0VMRUNUKSh2YWx1ZSk7XG4gIH1cblxuICBhcHBseUZpbHRlcih2YWx1ZSkge1xuICAgIHRoaXMuc2VsZWN0SW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IGlzU2VsZWN0ZWQ6IHZhbHVlICE9PSAnJyB9KSk7XG4gICAgdGhpcy5wcm9wcy5vbkZpbHRlcih0aGlzLnByb3BzLmNvbHVtbiwgRklMVEVSX1RZUEUuU0VMRUNUKSh2YWx1ZSk7XG4gIH1cblxuICBmaWx0ZXIoZSkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IGUudGFyZ2V0O1xuICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgaXNTZWxlY3RlZDogdmFsdWUgIT09ICcnIH0pKTtcbiAgICB0aGlzLnByb3BzLm9uRmlsdGVyKHRoaXMucHJvcHMuY29sdW1uLCBGSUxURVJfVFlQRS5TRUxFQ1QpKHZhbHVlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZSxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgIG9uRmlsdGVyLFxuICAgICAgY29sdW1uLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNvbXBhcmF0b3IsXG4gICAgICB3aXRob3V0RW1wdHlPcHRpb24sXG4gICAgICBjYXNlU2Vuc2l0aXZlLFxuICAgICAgZ2V0RmlsdGVyLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3Qgc2VsZWN0Q2xhc3MgPVxuICAgICAgYGZpbHRlciBzZWxlY3QtZmlsdGVyIGZvcm0tY29udHJvbCAke2NsYXNzTmFtZX0gJHt0aGlzLnN0YXRlLmlzU2VsZWN0ZWQgPyAnJyA6ICdwbGFjZWhvbGRlci1zZWxlY3RlZCd9YDtcblxuICAgIHJldHVybiAoXG4gICAgICA8c2VsZWN0XG4gICAgICAgIHsgLi4ucmVzdCB9XG4gICAgICAgIHJlZj17IG4gPT4gdGhpcy5zZWxlY3RJbnB1dCA9IG4gfVxuICAgICAgICBzdHlsZT17IHN0eWxlIH1cbiAgICAgICAgY2xhc3NOYW1lPXsgc2VsZWN0Q2xhc3MgfVxuICAgICAgICBvbkNoYW5nZT17IHRoaXMuZmlsdGVyIH1cbiAgICAgICAgb25DbGljaz17IGUgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSB9XG4gICAgICAgIGRlZmF1bHRWYWx1ZT17IGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogJycgfVxuICAgICAgPlxuICAgICAgICB7IHRoaXMuZ2V0T3B0aW9ucygpIH1cbiAgICAgIDwvc2VsZWN0PlxuICAgICk7XG4gIH1cbn1cblxuU2VsZWN0RmlsdGVyLnByb3BUeXBlcyA9IHtcbiAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGNvbHVtbjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBvcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNvbXBhcmF0b3I6IFByb3BUeXBlcy5vbmVPZihbTElLRSwgRVFdKSxcbiAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdpdGhvdXRFbXB0eU9wdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFueSxcbiAgY2FzZVNlbnNpdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIGdldEZpbHRlcjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cblNlbGVjdEZpbHRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGRlZmF1bHRWYWx1ZTogJycsXG4gIGNsYXNzTmFtZTogJycsXG4gIHdpdGhvdXRFbXB0eU9wdGlvbjogZmFsc2UsXG4gIGNvbXBhcmF0b3I6IEVRLFxuICBjYXNlU2Vuc2l0aXZlOiB0cnVlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RGaWx0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29tcG9uZW50cy9zZWxlY3QuanMiLCIvKiBlc2xpbnQgcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzOiAwICovXG4vKiBlc2xpbnQgbm8tcmV0dXJuLWFzc2lnbjogMCAqL1xuLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiAwICovXG4vKiBlc2xpbnQgcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXM6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgTElLRSwgRVEgfSBmcm9tICcuLi9jb21wYXJpc29uJztcbmltcG9ydCB7IEZJTFRFUl9UWVBFIH0gZnJvbSAnLi4vY29uc3QnO1xuXG5cbmZ1bmN0aW9uIG9wdGlvbnNFcXVhbHMoY3Vyck9wdHMsIHByZXZPcHRzKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjdXJyT3B0cyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChjdXJyT3B0c1trZXlzW2ldXSAhPT0gcHJldk9wdHNba2V5c1tpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGN1cnJPcHRzKS5sZW5ndGggPT09IE9iamVjdC5rZXlzKHByZXZPcHRzKS5sZW5ndGg7XG59XG5cbmNvbnN0IGdldFNlbGVjdGlvbnMgPSBjb250YWluZXIgPT5cbiAgQXJyYXkuZnJvbShjb250YWluZXIuc2VsZWN0ZWRPcHRpb25zKS5tYXAoaXRlbSA9PiBpdGVtLnZhbHVlKTtcblxuY2xhc3MgTXVsdGlTZWxlY3RGaWx0ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLmZpbHRlciA9IHRoaXMuZmlsdGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hcHBseUZpbHRlciA9IHRoaXMuYXBwbHlGaWx0ZXIuYmluZCh0aGlzKTtcbiAgICBjb25zdCBpc1NlbGVjdGVkID0gcHJvcHMuZGVmYXVsdFZhbHVlLm1hcChpdGVtID0+IHByb3BzLm9wdGlvbnNbaXRlbV0pLmxlbmd0aCA+IDA7XG4gICAgdGhpcy5zdGF0ZSA9IHsgaXNTZWxlY3RlZCB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBnZXRGaWx0ZXIgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB2YWx1ZSA9IGdldFNlbGVjdGlvbnModGhpcy5zZWxlY3RJbnB1dCk7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYXBwbHlGaWx0ZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIGV4cG9ydCBvbkZpbHRlciBmdW5jdGlvbiB0byBhbGxvdyB1c2VycyB0byBhY2Nlc3NcbiAgICBpZiAoZ2V0RmlsdGVyKSB7XG4gICAgICBnZXRGaWx0ZXIoKGZpbHRlclZhbCkgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdElucHV0LnZhbHVlID0gZmlsdGVyVmFsO1xuICAgICAgICB0aGlzLmFwcGx5RmlsdGVyKGZpbHRlclZhbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgbGV0IG5lZWRGaWx0ZXIgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUgIT09IHByZXZQcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgIG5lZWRGaWx0ZXIgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnNFcXVhbHModGhpcy5wcm9wcy5vcHRpb25zLCBwcmV2UHJvcHMub3B0aW9ucykpIHtcbiAgICAgIG5lZWRGaWx0ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobmVlZEZpbHRlcikge1xuICAgICAgdGhpcy5hcHBseUZpbHRlcih0aGlzLnNlbGVjdElucHV0LnZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBnZXRPcHRpb25zKCkge1xuICAgIGNvbnN0IG9wdGlvblRhZ3MgPSBbXTtcbiAgICBjb25zdCB7IG9wdGlvbnMsIHBsYWNlaG9sZGVyLCBjb2x1bW4sIHdpdGhvdXRFbXB0eU9wdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIXdpdGhvdXRFbXB0eU9wdGlvbikge1xuICAgICAgb3B0aW9uVGFncy5wdXNoKChcbiAgICAgICAgPG9wdGlvbiBrZXk9XCItMVwiIHZhbHVlPVwiXCI+eyBwbGFjZWhvbGRlciB8fCBgU2VsZWN0ICR7Y29sdW1uLnRleHR9Li4uYCB9PC9vcHRpb24+XG4gICAgICApKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChrZXkgPT5cbiAgICAgIG9wdGlvblRhZ3MucHVzaCg8b3B0aW9uIGtleT17IGtleSB9IHZhbHVlPXsga2V5IH0+eyBvcHRpb25zW2tleV0gfTwvb3B0aW9uPilcbiAgICApO1xuICAgIHJldHVybiBvcHRpb25UYWdzO1xuICB9XG5cbiAgY2xlYW5GaWx0ZXJlZCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9ICh0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSA/IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlIDogW107XG4gICAgdGhpcy5zZWxlY3RJbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuYXBwbHlGaWx0ZXIodmFsdWUpO1xuICB9XG5cbiAgYXBwbHlGaWx0ZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxICYmIHZhbHVlWzBdID09PSAnJykge1xuICAgICAgdmFsdWUgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBpc1NlbGVjdGVkOiB2YWx1ZS5sZW5ndGggPiAwIH0pKTtcbiAgICB0aGlzLnByb3BzLm9uRmlsdGVyKHRoaXMucHJvcHMuY29sdW1uLCBGSUxURVJfVFlQRS5NVUxUSVNFTEVDVCkodmFsdWUpO1xuICB9XG5cbiAgZmlsdGVyKGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFNlbGVjdGlvbnMoZS50YXJnZXQpO1xuICAgIHRoaXMuYXBwbHlGaWx0ZXIodmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgb25GaWx0ZXIsXG4gICAgICBjb2x1bW4sXG4gICAgICBvcHRpb25zLFxuICAgICAgY29tcGFyYXRvcixcbiAgICAgIHdpdGhvdXRFbXB0eU9wdGlvbixcbiAgICAgIGNhc2VTZW5zaXRpdmUsXG4gICAgICBnZXRGaWx0ZXIsXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBzZWxlY3RDbGFzcyA9XG4gICAgICBgZmlsdGVyIHNlbGVjdC1maWx0ZXIgZm9ybS1jb250cm9sICR7Y2xhc3NOYW1lfSAke3RoaXMuc3RhdGUuaXNTZWxlY3RlZCA/ICcnIDogJ3BsYWNlaG9sZGVyLXNlbGVjdGVkJ31gO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxzZWxlY3RcbiAgICAgICAgeyAuLi5yZXN0IH1cbiAgICAgICAgcmVmPXsgbiA9PiB0aGlzLnNlbGVjdElucHV0ID0gbiB9XG4gICAgICAgIHN0eWxlPXsgc3R5bGUgfVxuICAgICAgICBtdWx0aXBsZVxuICAgICAgICBjbGFzc05hbWU9eyBzZWxlY3RDbGFzcyB9XG4gICAgICAgIG9uQ2hhbmdlPXsgdGhpcy5maWx0ZXIgfVxuICAgICAgICBvbkNsaWNrPXsgZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpIH1cbiAgICAgICAgZGVmYXVsdFZhbHVlPXsgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiAnJyB9XG4gICAgICA+XG4gICAgICAgIHsgdGhpcy5nZXRPcHRpb25zKCkgfVxuICAgICAgPC9zZWxlY3Q+XG4gICAgKTtcbiAgfVxufVxuXG5NdWx0aVNlbGVjdEZpbHRlci5wcm9wVHlwZXMgPSB7XG4gIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBjb2x1bW46IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgb3B0aW9uczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBjb21wYXJhdG9yOiBQcm9wVHlwZXMub25lT2YoW0xJS0UsIEVRXSksXG4gIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB3aXRob3V0RW1wdHlPcHRpb246IFByb3BUeXBlcy5ib29sLFxuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5hcnJheSxcbiAgY2FzZVNlbnNpdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIGdldEZpbHRlcjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbk11bHRpU2VsZWN0RmlsdGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgZGVmYXVsdFZhbHVlOiBbXSxcbiAgY2xhc3NOYW1lOiAnJyxcbiAgd2l0aG91dEVtcHR5T3B0aW9uOiBmYWxzZSxcbiAgY29tcGFyYXRvcjogRVEsXG4gIGNhc2VTZW5zaXRpdmU6IHRydWVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpU2VsZWN0RmlsdGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIvc3JjL2NvbXBvbmVudHMvbXVsdGlzZWxlY3QuanMiLCIvKiBlc2xpbnQganN4LWExMXkvbm8tc3RhdGljLWVsZW1lbnQtaW50ZXJhY3Rpb25zOiAwICovXG4vKiBlc2xpbnQgcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzOiAwICovXG4vKiBlc2xpbnQgbm8tcmV0dXJuLWFzc2lnbjogMCAqL1xuXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCAqIGFzIENvbXBhcmF0b3IgZnJvbSAnLi4vY29tcGFyaXNvbic7XG5pbXBvcnQgeyBGSUxURVJfVFlQRSwgRklMVEVSX0RFTEFZIH0gZnJvbSAnLi4vY29uc3QnO1xuXG5jb25zdCBsZWdhbENvbXBhcmF0b3JzID0gW1xuICBDb21wYXJhdG9yLkVRLFxuICBDb21wYXJhdG9yLk5FLFxuICBDb21wYXJhdG9yLkdULFxuICBDb21wYXJhdG9yLkdFLFxuICBDb21wYXJhdG9yLkxULFxuICBDb21wYXJhdG9yLkxFXG5dO1xuXG5jbGFzcyBOdW1iZXJGaWx0ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLmNvbXBhcmF0b3JzID0gcHJvcHMuY29tcGFyYXRvcnMgfHwgbGVnYWxDb21wYXJhdG9ycztcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgIGxldCBpc1NlbGVjdGVkID0gcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlLm51bWJlciAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9wcy5vcHRpb25zICYmIGlzU2VsZWN0ZWQpIHtcbiAgICAgIGlzU2VsZWN0ZWQgPSBwcm9wcy5vcHRpb25zLmluZGV4T2YocHJvcHMuZGVmYXVsdFZhbHVlLm51bWJlcikgPiAtMTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHsgaXNTZWxlY3RlZCB9O1xuICAgIHRoaXMub25DaGFuZ2VOdW1iZXIgPSB0aGlzLm9uQ2hhbmdlTnVtYmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkNoYW5nZU51bWJlclNldCA9IHRoaXMub25DaGFuZ2VOdW1iZXJTZXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uQ2hhbmdlQ29tcGFyYXRvciA9IHRoaXMub25DaGFuZ2VDb21wYXJhdG9yLmJpbmQodGhpcyk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IGNvbHVtbiwgb25GaWx0ZXIsIGdldEZpbHRlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBjb21wYXJhdG9yID0gdGhpcy5udW1iZXJGaWx0ZXJDb21wYXJhdG9yLnZhbHVlO1xuICAgIGNvbnN0IG51bWJlciA9IHRoaXMubnVtYmVyRmlsdGVyLnZhbHVlO1xuICAgIGlmIChjb21wYXJhdG9yICYmIG51bWJlcikge1xuICAgICAgb25GaWx0ZXIoY29sdW1uLCBGSUxURVJfVFlQRS5OVU1CRVIpKHsgbnVtYmVyLCBjb21wYXJhdG9yIH0pO1xuICAgIH1cblxuICAgIC8vIGV4cG9ydCBvbkZpbHRlciBmdW5jdGlvbiB0byBhbGxvdyB1c2VycyB0byBhY2Nlc3NcbiAgICBpZiAoZ2V0RmlsdGVyKSB7XG4gICAgICBnZXRGaWx0ZXIoKGZpbHRlclZhbCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IGlzU2VsZWN0ZWQ6IChmaWx0ZXJWYWwgIT09ICcnKSB9KSk7XG4gICAgICAgIHRoaXMubnVtYmVyRmlsdGVyQ29tcGFyYXRvci52YWx1ZSA9IGZpbHRlclZhbC5jb21wYXJhdG9yO1xuICAgICAgICB0aGlzLm51bWJlckZpbHRlci52YWx1ZSA9IGZpbHRlclZhbC5udW1iZXI7XG5cbiAgICAgICAgb25GaWx0ZXIoY29sdW1uLCBGSUxURVJfVFlQRS5OVU1CRVIpKHtcbiAgICAgICAgICBudW1iZXI6IGZpbHRlclZhbC5udW1iZXIsXG4gICAgICAgICAgY29tcGFyYXRvcjogZmlsdGVyVmFsLmNvbXBhcmF0b3JcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgfVxuXG4gIG9uQ2hhbmdlTnVtYmVyKGUpIHtcbiAgICBjb25zdCB7IGRlbGF5LCBjb2x1bW4sIG9uRmlsdGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSB0aGlzLm51bWJlckZpbHRlckNvbXBhcmF0b3IudmFsdWU7XG4gICAgaWYgKGNvbXBhcmF0b3IgPT09ICcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJWYWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgb25GaWx0ZXIoY29sdW1uLCBGSUxURVJfVFlQRS5OVU1CRVIpKHsgbnVtYmVyOiBmaWx0ZXJWYWx1ZSwgY29tcGFyYXRvciB9KTtcbiAgICB9LCBkZWxheSk7XG4gIH1cblxuICBvbkNoYW5nZU51bWJlclNldChlKSB7XG4gICAgY29uc3QgeyBjb2x1bW4sIG9uRmlsdGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSB0aGlzLm51bWJlckZpbHRlckNvbXBhcmF0b3IudmFsdWU7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gZS50YXJnZXQ7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBpc1NlbGVjdGVkOiAodmFsdWUgIT09ICcnKSB9KSk7XG4gICAgLy8gaWYgKGNvbXBhcmF0b3IgPT09ICcnKSB7XG4gICAgLy8gICByZXR1cm47XG4gICAgLy8gfVxuICAgIG9uRmlsdGVyKGNvbHVtbiwgRklMVEVSX1RZUEUuTlVNQkVSKSh7IG51bWJlcjogdmFsdWUsIGNvbXBhcmF0b3IgfSk7XG4gIH1cblxuICBvbkNoYW5nZUNvbXBhcmF0b3IoZSkge1xuICAgIGNvbnN0IHsgY29sdW1uLCBvbkZpbHRlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMubnVtYmVyRmlsdGVyLnZhbHVlO1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAvLyBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgLy8gICByZXR1cm47XG4gICAgLy8gfVxuICAgIG9uRmlsdGVyKGNvbHVtbiwgRklMVEVSX1RZUEUuTlVNQkVSKSh7IG51bWJlcjogdmFsdWUsIGNvbXBhcmF0b3IgfSk7XG4gIH1cblxuICBnZXRDb21wYXJhdG9yT3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25UYWdzID0gW107XG4gICAgY29uc3QgeyB3aXRob3V0RW1wdHlDb21wYXJhdG9yT3B0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghd2l0aG91dEVtcHR5Q29tcGFyYXRvck9wdGlvbikge1xuICAgICAgb3B0aW9uVGFncy5wdXNoKDxvcHRpb24ga2V5PVwiLTFcIiAvPik7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb21wYXJhdG9ycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgb3B0aW9uVGFncy5wdXNoKFxuICAgICAgICA8b3B0aW9uIGtleT17IGkgfSB2YWx1ZT17IHRoaXMuY29tcGFyYXRvcnNbaV0gfT5cbiAgICAgICAgICB7IHRoaXMuY29tcGFyYXRvcnNbaV0gfVxuICAgICAgICA8L29wdGlvbj5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25UYWdzO1xuICB9XG5cbiAgZ2V0TnVtYmVyT3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25UYWdzID0gW107XG4gICAgY29uc3QgeyBvcHRpb25zLCBjb2x1bW4sIHdpdGhvdXRFbXB0eU51bWJlck9wdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIXdpdGhvdXRFbXB0eU51bWJlck9wdGlvbikge1xuICAgICAgb3B0aW9uVGFncy5wdXNoKFxuICAgICAgICA8b3B0aW9uIGtleT1cIi0xXCIgdmFsdWU9XCJcIj5cbiAgICAgICAgICB7IHRoaXMucHJvcHMucGxhY2Vob2xkZXIgfHwgYFNlbGVjdCAke2NvbHVtbi50ZXh0fS4uLmAgfVxuICAgICAgICA8L29wdGlvbj5cbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgb3B0aW9uVGFncy5wdXNoKDxvcHRpb24ga2V5PXsgaSB9IHZhbHVlPXsgb3B0aW9uc1tpXSB9Pnsgb3B0aW9uc1tpXSB9PC9vcHRpb24+KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvblRhZ3M7XG4gIH1cblxuICBhcHBseUZpbHRlcihmaWx0ZXJPYmopIHtcbiAgICBjb25zdCB7IGNvbHVtbiwgb25GaWx0ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBudW1iZXIsIGNvbXBhcmF0b3IgfSA9IGZpbHRlck9iajtcbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IGlzU2VsZWN0ZWQ6IChudW1iZXIgIT09ICcnKSB9KSk7XG4gICAgdGhpcy5udW1iZXJGaWx0ZXJDb21wYXJhdG9yLnZhbHVlID0gY29tcGFyYXRvcjtcbiAgICB0aGlzLm51bWJlckZpbHRlci52YWx1ZSA9IG51bWJlcjtcbiAgICBvbkZpbHRlcihjb2x1bW4sIEZJTFRFUl9UWVBFLk5VTUJFUikoeyBudW1iZXIsIGNvbXBhcmF0b3IgfSk7XG4gIH1cblxuICBjbGVhbkZpbHRlcmVkKCkge1xuICAgIGNvbnN0IHsgY29sdW1uLCBvbkZpbHRlciwgZGVmYXVsdFZhbHVlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHZhbHVlID0gZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlLm51bWJlciA6ICcnO1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSBkZWZhdWx0VmFsdWUgPyBkZWZhdWx0VmFsdWUuY29tcGFyYXRvciA6ICcnO1xuICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgaXNTZWxlY3RlZDogKHZhbHVlICE9PSAnJykgfSkpO1xuICAgIHRoaXMubnVtYmVyRmlsdGVyQ29tcGFyYXRvci52YWx1ZSA9IGNvbXBhcmF0b3I7XG4gICAgdGhpcy5udW1iZXJGaWx0ZXIudmFsdWUgPSB2YWx1ZTtcbiAgICBvbkZpbHRlcihjb2x1bW4sIEZJTFRFUl9UWVBFLk5VTUJFUikoeyBudW1iZXI6IHZhbHVlLCBjb21wYXJhdG9yIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaXNTZWxlY3RlZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICBjb2x1bW4sXG4gICAgICBvcHRpb25zLFxuICAgICAgc3R5bGUsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBudW1iZXJTdHlsZSxcbiAgICAgIG51bWJlckNsYXNzTmFtZSxcbiAgICAgIGNvbXBhcmF0b3JTdHlsZSxcbiAgICAgIGNvbXBhcmF0b3JDbGFzc05hbWUsXG4gICAgICBwbGFjZWhvbGRlclxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHNlbGVjdENsYXNzID0gYFxuICAgICAgc2VsZWN0LWZpbHRlciBcbiAgICAgIG51bWJlci1maWx0ZXItaW5wdXQgXG4gICAgICBmb3JtLWNvbnRyb2wgXG4gICAgICAke251bWJlckNsYXNzTmFtZX0gXG4gICAgICAkeyFpc1NlbGVjdGVkID8gJ3BsYWNlaG9sZGVyLXNlbGVjdGVkJyA6ICcnfVxuICAgIGA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBvbkNsaWNrPXsgZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpIH1cbiAgICAgICAgY2xhc3NOYW1lPXsgYGZpbHRlciBudW1iZXItZmlsdGVyICR7Y2xhc3NOYW1lfWAgfVxuICAgICAgICBzdHlsZT17IHN0eWxlIH1cbiAgICAgID5cbiAgICAgICAgPHNlbGVjdFxuICAgICAgICAgIHJlZj17IG4gPT4gdGhpcy5udW1iZXJGaWx0ZXJDb21wYXJhdG9yID0gbiB9XG4gICAgICAgICAgc3R5bGU9eyBjb21wYXJhdG9yU3R5bGUgfVxuICAgICAgICAgIGNsYXNzTmFtZT17IGBudW1iZXItZmlsdGVyLWNvbXBhcmF0b3IgZm9ybS1jb250cm9sICR7Y29tcGFyYXRvckNsYXNzTmFtZX1gIH1cbiAgICAgICAgICBvbkNoYW5nZT17IHRoaXMub25DaGFuZ2VDb21wYXJhdG9yIH1cbiAgICAgICAgICBkZWZhdWx0VmFsdWU9eyBkZWZhdWx0VmFsdWUgPyBkZWZhdWx0VmFsdWUuY29tcGFyYXRvciA6ICcnIH1cbiAgICAgICAgPlxuICAgICAgICAgIHsgdGhpcy5nZXRDb21wYXJhdG9yT3B0aW9ucygpIH1cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIHtcbiAgICAgICAgICBvcHRpb25zID9cbiAgICAgICAgICAgIDxzZWxlY3RcbiAgICAgICAgICAgICAgcmVmPXsgbiA9PiB0aGlzLm51bWJlckZpbHRlciA9IG4gfVxuICAgICAgICAgICAgICBzdHlsZT17IG51bWJlclN0eWxlIH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXsgc2VsZWN0Q2xhc3MgfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17IHRoaXMub25DaGFuZ2VOdW1iZXJTZXQgfVxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9eyBkZWZhdWx0VmFsdWUgPyBkZWZhdWx0VmFsdWUubnVtYmVyIDogJycgfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7IHRoaXMuZ2V0TnVtYmVyT3B0aW9ucygpIH1cbiAgICAgICAgICAgIDwvc2VsZWN0PiA6XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgcmVmPXsgbiA9PiB0aGlzLm51bWJlckZpbHRlciA9IG4gfVxuICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgc3R5bGU9eyBudW1iZXJTdHlsZSB9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17IGBudW1iZXItZmlsdGVyLWlucHV0IGZvcm0tY29udHJvbCAke251bWJlckNsYXNzTmFtZX1gIH1cbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9eyBwbGFjZWhvbGRlciB8fCBgRW50ZXIgJHtjb2x1bW4udGV4dH0uLi5gIH1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyB0aGlzLm9uQ2hhbmdlTnVtYmVyIH1cbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXsgZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlLm51bWJlciA6ICcnIH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIH1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuTnVtYmVyRmlsdGVyLnByb3BUeXBlcyA9IHtcbiAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGNvbHVtbjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBvcHRpb25zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSxcbiAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIG51bWJlcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICAgIGNvbXBhcmF0b3I6IFByb3BUeXBlcy5vbmVPZihbLi4ubGVnYWxDb21wYXJhdG9ycywgJyddKVxuICB9KSxcbiAgZGVsYXk6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8qIGVzbGludCBjb25zaXN0ZW50LXJldHVybjogMCAqL1xuICBjb21wYXJhdG9yczogKHByb3BzLCBwcm9wTmFtZSkgPT4ge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNbcHJvcE5hbWVdLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsZXQgY29tcGFyYXRvcklzVmFsaWQgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVnYWxDb21wYXJhdG9ycy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBpZiAobGVnYWxDb21wYXJhdG9yc1tqXSA9PT0gcHJvcHNbcHJvcE5hbWVdW2ldIHx8IHByb3BzW3Byb3BOYW1lXVtpXSA9PT0gJycpIHtcbiAgICAgICAgICBjb21wYXJhdG9ySXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY29tcGFyYXRvcklzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgTnVtYmVyIGNvbXBhcmF0b3IgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgICBVc2Ugb25seSAke2xlZ2FsQ29tcGFyYXRvcnN9YCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgd2l0aG91dEVtcHR5Q29tcGFyYXRvck9wdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIHdpdGhvdXRFbXB0eU51bWJlck9wdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNvbXBhcmF0b3JTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY29tcGFyYXRvckNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbnVtYmVyU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG51bWJlckNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZ2V0RmlsdGVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuTnVtYmVyRmlsdGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgZGVsYXk6IEZJTFRFUl9ERUxBWSxcbiAgb3B0aW9uczogdW5kZWZpbmVkLFxuICBkZWZhdWx0VmFsdWU6IHtcbiAgICBudW1iZXI6IHVuZGVmaW5lZCxcbiAgICBjb21wYXJhdG9yOiAnJ1xuICB9LFxuICB3aXRob3V0RW1wdHlDb21wYXJhdG9yT3B0aW9uOiBmYWxzZSxcbiAgd2l0aG91dEVtcHR5TnVtYmVyT3B0aW9uOiBmYWxzZSxcbiAgY29tcGFyYXRvcnM6IGxlZ2FsQ29tcGFyYXRvcnMsXG4gIHBsYWNlaG9sZGVyOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIGNsYXNzTmFtZTogJycsXG4gIGNvbXBhcmF0b3JTdHlsZTogdW5kZWZpbmVkLFxuICBjb21wYXJhdG9yQ2xhc3NOYW1lOiAnJyxcbiAgbnVtYmVyU3R5bGU6IHVuZGVmaW5lZCxcbiAgbnVtYmVyQ2xhc3NOYW1lOiAnJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTnVtYmVyRmlsdGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1maWx0ZXIvc3JjL2NvbXBvbmVudHMvbnVtYmVyLmpzIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuLyogZXNsaW50IGpzeC1hMTF5L25vLXN0YXRpYy1lbGVtZW50LWludGVyYWN0aW9uczogMCAqL1xuLyogZXNsaW50IG5vLXJldHVybi1hc3NpZ246IDAgKi9cbi8qIGVzbGludCBwcmVmZXItdGVtcGxhdGU6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQcm9wVHlwZXMgfSBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0ICogYXMgQ29tcGFyYXRvciBmcm9tICcuLi9jb21wYXJpc29uJztcbmltcG9ydCB7IEZJTFRFUl9UWVBFIH0gZnJvbSAnLi4vY29uc3QnO1xuXG5jb25zdCBsZWdhbENvbXBhcmF0b3JzID0gW1xuICBDb21wYXJhdG9yLkVRLFxuICBDb21wYXJhdG9yLk5FLFxuICBDb21wYXJhdG9yLkdULFxuICBDb21wYXJhdG9yLkdFLFxuICBDb21wYXJhdG9yLkxULFxuICBDb21wYXJhdG9yLkxFXG5dO1xuXG5mdW5jdGlvbiBkYXRlUGFyc2VyKGQpIHtcbiAgcmV0dXJuIGAke2QuZ2V0RnVsbFllYXIoKX0tJHsoJzAnICsgKGQuZ2V0TW9udGgoKSArIDEpKS5zbGljZSgtMil9LSR7KCcwJyArIGQuZ2V0RGF0ZSgpKS5zbGljZSgtMil9YDtcbn1cblxuY2xhc3MgRGF0ZUZpbHRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgdGhpcy5jb21wYXJhdG9ycyA9IHByb3BzLmNvbXBhcmF0b3JzIHx8IGxlZ2FsQ29tcGFyYXRvcnM7XG4gICAgdGhpcy5hcHBseUZpbHRlciA9IHRoaXMuYXBwbHlGaWx0ZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uQ2hhbmdlRGF0ZSA9IHRoaXMub25DaGFuZ2VEYXRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkNoYW5nZUNvbXBhcmF0b3IgPSB0aGlzLm9uQ2hhbmdlQ29tcGFyYXRvci5iaW5kKHRoaXMpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBnZXRGaWx0ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgY29tcGFyYXRvciA9IHRoaXMuZGF0ZUZpbHRlckNvbXBhcmF0b3IudmFsdWU7XG4gICAgY29uc3QgZGF0ZSA9IHRoaXMuaW5wdXREYXRlLnZhbHVlO1xuICAgIGlmIChjb21wYXJhdG9yICYmIGRhdGUpIHtcbiAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoZGF0ZSwgY29tcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLy8gZXhwb3J0IG9uRmlsdGVyIGZ1bmN0aW9uIHRvIGFsbG93IHVzZXJzIHRvIGFjY2Vzc1xuICAgIGlmIChnZXRGaWx0ZXIpIHtcbiAgICAgIGdldEZpbHRlcigoZmlsdGVyVmFsKSA9PiB7XG4gICAgICAgIHRoaXMuZGF0ZUZpbHRlckNvbXBhcmF0b3IudmFsdWUgPSBmaWx0ZXJWYWwuY29tcGFyYXRvcjtcbiAgICAgICAgdGhpcy5pbnB1dERhdGUudmFsdWUgPSBkYXRlUGFyc2VyKGZpbHRlclZhbC5kYXRlKTtcblxuICAgICAgICB0aGlzLmFwcGx5RmlsdGVyKGZpbHRlclZhbC5kYXRlLCBmaWx0ZXJWYWwuY29tcGFyYXRvcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgfVxuXG4gIG9uQ2hhbmdlRGF0ZShlKSB7XG4gICAgY29uc3QgY29tcGFyYXRvciA9IHRoaXMuZGF0ZUZpbHRlckNvbXBhcmF0b3IudmFsdWU7XG4gICAgY29uc3QgZmlsdGVyVmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICB0aGlzLmFwcGx5RmlsdGVyKGZpbHRlclZhbHVlLCBjb21wYXJhdG9yKTtcbiAgfVxuXG4gIG9uQ2hhbmdlQ29tcGFyYXRvcihlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0RGF0ZS52YWx1ZTtcbiAgICBjb25zdCBjb21wYXJhdG9yID0gZS50YXJnZXQudmFsdWU7XG4gICAgdGhpcy5hcHBseUZpbHRlcih2YWx1ZSwgY29tcGFyYXRvcik7XG4gIH1cblxuICBnZXRDb21wYXJhdG9yT3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25UYWdzID0gW107XG4gICAgY29uc3QgeyB3aXRob3V0RW1wdHlDb21wYXJhdG9yT3B0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghd2l0aG91dEVtcHR5Q29tcGFyYXRvck9wdGlvbikge1xuICAgICAgb3B0aW9uVGFncy5wdXNoKDxvcHRpb24ga2V5PVwiLTFcIiAvPik7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb21wYXJhdG9ycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgb3B0aW9uVGFncy5wdXNoKFxuICAgICAgICA8b3B0aW9uIGtleT17IGkgfSB2YWx1ZT17IHRoaXMuY29tcGFyYXRvcnNbaV0gfT5cbiAgICAgICAgICB7IHRoaXMuY29tcGFyYXRvcnNbaV0gfVxuICAgICAgICA8L29wdGlvbj5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25UYWdzO1xuICB9XG5cbiAgZ2V0RGVmYXVsdERhdGUoKSB7XG4gICAgbGV0IGRlZmF1bHREYXRlID0gJyc7XG4gICAgY29uc3QgeyBkZWZhdWx0VmFsdWUgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUuZGF0ZSkge1xuICAgICAgLy8gU2V0IHRoZSBhcHByb3ByaWF0ZSBmb3JtYXQgZm9yIHRoZSBpbnB1dCB0eXBlPWRhdGUsIGkuZS4gXCJZWVlZLU1NLUREXCJcbiAgICAgIGRlZmF1bHREYXRlID0gZGF0ZVBhcnNlcihuZXcgRGF0ZShkZWZhdWx0VmFsdWUuZGF0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdERhdGU7XG4gIH1cblxuICBhcHBseUZpbHRlcih2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgIC8vIGlmICghY29tcGFyYXRvciB8fCAhdmFsdWUpIHtcbiAgICAvLyAgcmV0dXJuO1xuICAgIC8vIH1cbiAgICBjb25zdCB7IGNvbHVtbiwgb25GaWx0ZXIsIGRlbGF5IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGV4ZWN1dGUgPSAoKSA9PiB7XG4gICAgICAvLyBJbmNvbWluZyB2YWx1ZSBzaG91bGQgYWx3YXlzIGJlIGEgc3RyaW5nLCBhbmQgdGhlIGRlZmF1bHREYXRlXG4gICAgICAvLyBhYm92ZSBpcyBpbXBsZW1lbnRlZCBhcyBhbiBlbXB0eSBzdHJpbmcsIHNvIHdlIGNhbiBqdXN0IGNoZWNrIGZvciB0aGF0LlxuICAgICAgLy8gaW5zdGVhZCBvZiBwYXJzaW5nIGFuIGludmFsaWQgRGF0ZS4gVGhlIGZpbHRlciBmdW5jdGlvbiB3aWxsIGludGVycHJldFxuICAgICAgLy8gbnVsbCBhcyBhbiBlbXB0eSBkYXRlIGZpZWxkXG4gICAgICBjb25zdCBkYXRlID0gdmFsdWUgPT09ICcnID8gbnVsbCA6IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIG9uRmlsdGVyKGNvbHVtbiwgRklMVEVSX1RZUEUuREFURSkoeyBkYXRlLCBjb21wYXJhdG9yIH0pO1xuICAgIH07XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHsgZXhlY3V0ZSgpOyB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4ZWN1dGUoKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBjb2x1bW46IHsgdGV4dCB9LFxuICAgICAgc3R5bGUsXG4gICAgICBjb21wYXJhdG9yU3R5bGUsXG4gICAgICBkYXRlU3R5bGUsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBjb21wYXJhdG9yQ2xhc3NOYW1lLFxuICAgICAgZGF0ZUNsYXNzTmFtZSxcbiAgICAgIGRlZmF1bHRWYWx1ZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgb25DbGljaz17IGUgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSB9XG4gICAgICAgIGNsYXNzTmFtZT17IGBmaWx0ZXIgZGF0ZS1maWx0ZXIgJHtjbGFzc05hbWV9YCB9XG4gICAgICAgIHN0eWxlPXsgc3R5bGUgfVxuICAgICAgPlxuICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgcmVmPXsgbiA9PiB0aGlzLmRhdGVGaWx0ZXJDb21wYXJhdG9yID0gbiB9XG4gICAgICAgICAgc3R5bGU9eyBjb21wYXJhdG9yU3R5bGUgfVxuICAgICAgICAgIGNsYXNzTmFtZT17IGBkYXRlLWZpbHRlci1jb21wYXJhdG9yIGZvcm0tY29udHJvbCAke2NvbXBhcmF0b3JDbGFzc05hbWV9YCB9XG4gICAgICAgICAgb25DaGFuZ2U9eyB0aGlzLm9uQ2hhbmdlQ29tcGFyYXRvciB9XG4gICAgICAgICAgZGVmYXVsdFZhbHVlPXsgZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlLmNvbXBhcmF0b3IgOiAnJyB9XG4gICAgICAgID5cbiAgICAgICAgICB7IHRoaXMuZ2V0Q29tcGFyYXRvck9wdGlvbnMoKSB9XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICByZWY9eyBuID0+IHRoaXMuaW5wdXREYXRlID0gbiB9XG4gICAgICAgICAgY2xhc3NOYW1lPXsgYGZpbHRlciBkYXRlLWZpbHRlci1pbnB1dCBmb3JtLWNvbnRyb2wgJHtkYXRlQ2xhc3NOYW1lfWAgfVxuICAgICAgICAgIHN0eWxlPXsgZGF0ZVN0eWxlIH1cbiAgICAgICAgICB0eXBlPVwiZGF0ZVwiXG4gICAgICAgICAgb25DaGFuZ2U9eyB0aGlzLm9uQ2hhbmdlRGF0ZSB9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9eyBwbGFjZWhvbGRlciB8fCBgRW50ZXIgJHt0ZXh0fS4uLmAgfVxuICAgICAgICAgIGRlZmF1bHRWYWx1ZT17IHRoaXMuZ2V0RGVmYXVsdERhdGUoKSB9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkRhdGVGaWx0ZXIucHJvcFR5cGVzID0ge1xuICBvbkZpbHRlcjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgY29sdW1uOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGRlbGF5OiBQcm9wVHlwZXMubnVtYmVyLFxuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZGF0ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIGNvbXBhcmF0b3I6IFByb3BUeXBlcy5vbmVPZihbLi4ubGVnYWxDb21wYXJhdG9ycywgJyddKVxuICB9KSxcbiAgLyogZXNsaW50IGNvbnNpc3RlbnQtcmV0dXJuOiAwICovXG4gIGNvbXBhcmF0b3JzOiAocHJvcHMsIHByb3BOYW1lKSA9PiB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1twcm9wTmFtZV0ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxldCBjb21wYXJhdG9ySXNWYWxpZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZWdhbENvbXBhcmF0b3JzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGlmIChsZWdhbENvbXBhcmF0b3JzW2pdID09PSBwcm9wc1twcm9wTmFtZV1baV0gfHwgcHJvcHNbcHJvcE5hbWVdW2ldID09PSAnJykge1xuICAgICAgICAgIGNvbXBhcmF0b3JJc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjb21wYXJhdG9ySXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBEYXRlIGNvbXBhcmF0b3IgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgICBVc2Ugb25seSAke2xlZ2FsQ29tcGFyYXRvcnN9YCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgd2l0aG91dEVtcHR5Q29tcGFyYXRvck9wdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjb21wYXJhdG9yU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGRhdGVTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjb21wYXJhdG9yQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBkYXRlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBnZXRGaWx0ZXI6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5EYXRlRmlsdGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgZGVsYXk6IDAsXG4gIGRlZmF1bHRWYWx1ZToge1xuICAgIGRhdGU6IHVuZGVmaW5lZCxcbiAgICBjb21wYXJhdG9yOiAnJ1xuICB9LFxuICB3aXRob3V0RW1wdHlDb21wYXJhdG9yT3B0aW9uOiBmYWxzZSxcbiAgY29tcGFyYXRvcnM6IGxlZ2FsQ29tcGFyYXRvcnMsXG4gIHBsYWNlaG9sZGVyOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIGNsYXNzTmFtZTogJycsXG4gIGNvbXBhcmF0b3JTdHlsZTogdW5kZWZpbmVkLFxuICBjb21wYXJhdG9yQ2xhc3NOYW1lOiAnJyxcbiAgZGF0ZVN0eWxlOiB1bmRlZmluZWQsXG4gIGRhdGVDbGFzc05hbWU6ICcnXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IERhdGVGaWx0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWZpbHRlci9zcmMvY29tcG9uZW50cy9kYXRlLmpzIiwiLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiAwICovXG5cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZmlsdGVycyB9IGZyb20gJy4vZmlsdGVyJztcbmltcG9ydCB7IExJS0UsIEVRIH0gZnJvbSAnLi9jb21wYXJpc29uJztcbmltcG9ydCB7IEZJTFRFUl9UWVBFIH0gZnJvbSAnLi9jb25zdCc7XG5cbmV4cG9ydCBkZWZhdWx0IChCYXNlLCB7XG4gIF8sXG4gIHJlbW90ZVJlc29sdmVyXG59KSA9PlxuICBjbGFzcyBGaWx0ZXJXcmFwcGVyIGV4dGVuZHMgcmVtb3RlUmVzb2x2ZXIoQ29tcG9uZW50KSB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgIHN0b3JlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgICBjb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZFxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLnN0YXRlID0geyBjdXJyRmlsdGVyczoge30sIGlzRGF0YUNoYW5nZWQ6IHByb3BzLmlzRGF0YUNoYW5nZWQgfHwgZmFsc2UgfTtcbiAgICAgIHRoaXMub25GaWx0ZXIgPSB0aGlzLm9uRmlsdGVyLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLm9uRXh0ZXJuYWxGaWx0ZXIgPSB0aGlzLm9uRXh0ZXJuYWxGaWx0ZXIuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHsgaXNEYXRhQ2hhbmdlZCwgc3RvcmUsIGNvbHVtbnMgfSkge1xuICAgICAgLy8gY29uc2lkZXIgdG8gdXNlIGxvZGFzaC5pc0VxdWFsXG4gICAgICBjb25zdCBpc1JlbW90ZUZpbHRlciA9IHRoaXMuaXNSZW1vdGVGaWx0ZXJpbmcoKSB8fCB0aGlzLmlzUmVtb3RlUGFnaW5hdGlvbigpO1xuICAgICAgaWYgKGlzUmVtb3RlRmlsdGVyIHx8XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuc3RhdGUuY3VyckZpbHRlcnMpICE9PSBKU09OLnN0cmluZ2lmeShzdG9yZS5maWx0ZXJzKSkge1xuICAgICAgICAvLyBJIHRoaW5rIHRoaXMgY29uZGl0aW9uIG9ubHkgaXNSZW1vdGVGaWx0ZXIgaXMgZW5vdWdoXG4gICAgICAgIHN0b3JlLmZpbHRlcmVkRGF0YSA9IHN0b3JlLmdldEFsbERhdGEoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBpc0RhdGFDaGFuZ2VkOiB0cnVlLCBjdXJyRmlsdGVyczogc3RvcmUuZmlsdGVycyB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zdGF0ZS5jdXJyRmlsdGVycykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0b3JlLmZpbHRlcmVkRGF0YSA9IGZpbHRlcnMoc3RvcmUsIGNvbHVtbnMsIF8pKHRoaXMuc3RhdGUuY3VyckZpbHRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgaXNEYXRhQ2hhbmdlZCB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmlsdGVyIHRoZSB0YWJsZSBsaWtlIGJlbG93OlxuICAgICAqIG9uRmlsdGVyKGNvbHVtbiwgZmlsdGVyVHlwZSkoZmlsdGVyVmFsKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsdGVyVHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWx0ZXJWYWwgLSB1c2VyIGlucHV0IGZvciBmaWx0ZXJpbmcuXG4gICAgICovXG4gICAgb25GaWx0ZXIoY29sdW1uLCBmaWx0ZXJUeXBlKSB7XG4gICAgICByZXR1cm4gKGZpbHRlclZhbCkgPT4ge1xuICAgICAgICBjb25zdCB7IHN0b3JlLCBjb2x1bW5zIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAvLyB3YXRjaCBvdXQgaGVyZSBpZiBtaWdyYXRpb24gdG8gY29udGV4dCBBUEksICMzMzRcbiAgICAgICAgY29uc3QgY3VyckZpbHRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBzdG9yZS5maWx0ZXJzKTtcbiAgICAgICAgY29uc3QgeyBkYXRhRmllbGQsIGZpbHRlciB9ID0gY29sdW1uO1xuXG4gICAgICAgIGNvbnN0IG5lZWRDbGVhckZpbHRlcnMgPVxuICAgICAgICAgICFfLmlzRGVmaW5lZChmaWx0ZXJWYWwpIHx8XG4gICAgICAgICAgZmlsdGVyVmFsID09PSAnJyB8fFxuICAgICAgICAgIGZpbHRlclZhbC5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgaWYgKG5lZWRDbGVhckZpbHRlcnMpIHtcbiAgICAgICAgICBkZWxldGUgY3VyckZpbHRlcnNbZGF0YUZpZWxkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZWxlY3QgZGVmYXVsdCBjb21wYXJhdG9yIGlzIEVRLCBvdGhlcnMgYXJlIExJS0VcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb21wYXJhdG9yID0gKFxuICAgICAgICAgICAgICAoZmlsdGVyVHlwZSA9PT0gRklMVEVSX1RZUEUuU0VMRUNUKSB8fCAoXG4gICAgICAgICAgICAgICAgZmlsdGVyVHlwZSA9PT0gRklMVEVSX1RZUEUuTVVMVElTRUxFQ1QpID8gRVEgOiBMSUtFXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlXG4gICAgICAgICAgfSA9IGZpbHRlci5wcm9wcztcbiAgICAgICAgICBjdXJyRmlsdGVyc1tkYXRhRmllbGRdID0geyBmaWx0ZXJWYWwsIGZpbHRlclR5cGUsIGNvbXBhcmF0b3IsIGNhc2VTZW5zaXRpdmUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0b3JlLmZpbHRlcnMgPSBjdXJyRmlsdGVycztcblxuICAgICAgICBpZiAodGhpcy5pc1JlbW90ZUZpbHRlcmluZygpIHx8IHRoaXMuaXNSZW1vdGVQYWdpbmF0aW9uKCkpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVJlbW90ZUZpbHRlckNoYW5nZSgpO1xuICAgICAgICAgIC8vIHdoZW4gcmVtb3RlIGZpbHRlcmluZyBpcyBlbmFibGUsIGRvbnQgc2V0IGN1cnJGaWx0ZXJzIHN0YXRlXG4gICAgICAgICAgLy8gaW4gdGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMsXG4gICAgICAgICAgLy8gaXQncyB0aGUga2V5IHBvaW50IHRoYXQgd2UgY2FuIGtub3cgdGhlIGZpbHRlciBpcyBjaGFuZ2VkXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RvcmUuZmlsdGVyZWREYXRhID0gZmlsdGVycyhzdG9yZSwgY29sdW1ucywgXykoY3VyckZpbHRlcnMpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IGN1cnJGaWx0ZXJzLCBpc0RhdGFDaGFuZ2VkOiB0cnVlIH0pKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb25FeHRlcm5hbEZpbHRlcihjb2x1bW4sIGZpbHRlclR5cGUpIHtcbiAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5vbkZpbHRlcihjb2x1bW4sIGZpbHRlclR5cGUpKHZhbHVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEJhc2VcbiAgICAgICAgICB7IC4uLnRoaXMucHJvcHMgfVxuICAgICAgICAgIGRhdGE9eyB0aGlzLnByb3BzLnN0b3JlLmRhdGEgfVxuICAgICAgICAgIG9uRmlsdGVyPXsgdGhpcy5vbkZpbHRlciB9XG4gICAgICAgICAgb25FeHRlcm5hbEZpbHRlcj17IHRoaXMub25FeHRlcm5hbEZpbHRlciB9XG4gICAgICAgICAgaXNEYXRhQ2hhbmdlZD17IHRoaXMuc3RhdGUuaXNEYXRhQ2hhbmdlZCB9XG4gICAgICAgIC8+XG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy93cmFwcGVyLmpzIiwiLyogZXNsaW50IGVxZXFlcTogMCAqL1xuLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cbmltcG9ydCB7IEZJTFRFUl9UWVBFIH0gZnJvbSAnLi9jb25zdCc7XG5pbXBvcnQgeyBMSUtFLCBFUSwgTkUsIEdULCBHRSwgTFQsIExFIH0gZnJvbSAnLi9jb21wYXJpc29uJztcblxuZXhwb3J0IGNvbnN0IGZpbHRlckJ5VGV4dCA9IF8gPT4gKFxuICBkYXRhLFxuICBkYXRhRmllbGQsXG4gIHsgZmlsdGVyVmFsOiB1c2VySW5wdXQgPSAnJywgY29tcGFyYXRvciA9IExJS0UsIGNhc2VTZW5zaXRpdmUgfSxcbiAgY3VzdG9tRmlsdGVyVmFsdWVcbikgPT4ge1xuICAvLyBtYWtlIHN1cmUgZmlsdGVyIHZhbHVlIHRvIGJlIGEgc3RyaW5nXG4gIGNvbnN0IGZpbHRlclZhbCA9IHVzZXJJbnB1dC50b1N0cmluZygpO1xuXG4gIHJldHVybiAoXG4gICAgZGF0YS5maWx0ZXIoKHJvdykgPT4ge1xuICAgICAgbGV0IGNlbGwgPSBfLmdldChyb3csIGRhdGFGaWVsZCk7XG4gICAgICBpZiAoY3VzdG9tRmlsdGVyVmFsdWUpIHtcbiAgICAgICAgY2VsbCA9IGN1c3RvbUZpbHRlclZhbHVlKGNlbGwsIHJvdyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjZWxsU3RyID0gXy5pc0RlZmluZWQoY2VsbCkgPyBjZWxsLnRvU3RyaW5nKCkgOiAnJztcbiAgICAgIGlmIChjb21wYXJhdG9yID09PSBFUSkge1xuICAgICAgICByZXR1cm4gY2VsbFN0ciA9PT0gZmlsdGVyVmFsO1xuICAgICAgfVxuICAgICAgaWYgKGNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIGNlbGxTdHIuaW5jbHVkZXMoZmlsdGVyVmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNlbGxTdHIudG9Mb2NhbGVVcHBlckNhc2UoKS5pbmRleE9mKGZpbHRlclZhbC50b0xvY2FsZVVwcGVyQ2FzZSgpKSAhPT0gLTE7XG4gICAgfSlcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJCeU51bWJlciA9IF8gPT4gKFxuICBkYXRhLFxuICBkYXRhRmllbGQsXG4gIHsgZmlsdGVyVmFsOiB7IGNvbXBhcmF0b3IsIG51bWJlciB9IH0sXG4gIGN1c3RvbUZpbHRlclZhbHVlXG4pID0+IChcbiAgZGF0YS5maWx0ZXIoKHJvdykgPT4ge1xuICAgIGlmIChudW1iZXIgPT09ICcnIHx8ICFjb21wYXJhdG9yKSByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgdmFsaWQgPSB0cnVlO1xuICAgIGxldCBjZWxsID0gXy5nZXQocm93LCBkYXRhRmllbGQpO1xuICAgIGlmIChjdXN0b21GaWx0ZXJWYWx1ZSkge1xuICAgICAgY2VsbCA9IGN1c3RvbUZpbHRlclZhbHVlKGNlbGwsIHJvdyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjb21wYXJhdG9yKSB7XG4gICAgICBjYXNlIEVROiB7XG4gICAgICAgIGlmIChjZWxsICE9IG51bWJlcikge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEdUOiB7XG4gICAgICAgIGlmIChjZWxsIDw9IG51bWJlcikge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEdFOiB7XG4gICAgICAgIGlmIChjZWxsIDwgbnVtYmVyKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgTFQ6IHtcbiAgICAgICAgaWYgKGNlbGwgPj0gbnVtYmVyKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgTEU6IHtcbiAgICAgICAgaWYgKGNlbGwgPiBudW1iZXIpIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBORToge1xuICAgICAgICBpZiAoY2VsbCA9PSBudW1iZXIpIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdOdW1iZXIgY29tcGFyYXRvciBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH0pXG4pO1xuXG5leHBvcnQgY29uc3QgZmlsdGVyQnlEYXRlID0gXyA9PiAoXG4gIGRhdGEsXG4gIGRhdGFGaWVsZCxcbiAgeyBmaWx0ZXJWYWw6IHsgY29tcGFyYXRvciwgZGF0ZSB9IH0sXG4gIGN1c3RvbUZpbHRlclZhbHVlXG4pID0+IHtcbiAgaWYgKCFkYXRlIHx8ICFjb21wYXJhdG9yKSByZXR1cm4gZGF0YTtcbiAgY29uc3QgZmlsdGVyRGF0ZSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICBjb25zdCBmaWx0ZXJNb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgY29uc3QgZmlsdGVyWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblxuICByZXR1cm4gZGF0YS5maWx0ZXIoKHJvdykgPT4ge1xuICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgbGV0IGNlbGwgPSBfLmdldChyb3csIGRhdGFGaWVsZCk7XG5cbiAgICBpZiAoY3VzdG9tRmlsdGVyVmFsdWUpIHtcbiAgICAgIGNlbGwgPSBjdXN0b21GaWx0ZXJWYWx1ZShjZWxsLCByb3cpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2VsbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGNlbGwgPSBuZXcgRGF0ZShjZWxsKTtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXREYXRlID0gY2VsbC5nZXREYXRlKCk7XG4gICAgY29uc3QgdGFyZ2V0TW9udGggPSBjZWxsLmdldE1vbnRoKCk7XG4gICAgY29uc3QgdGFyZ2V0WWVhciA9IGNlbGwuZ2V0RnVsbFllYXIoKTtcblxuXG4gICAgc3dpdGNoIChjb21wYXJhdG9yKSB7XG4gICAgICBjYXNlIEVROiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBmaWx0ZXJEYXRlICE9PSB0YXJnZXREYXRlIHx8XG4gICAgICAgICAgZmlsdGVyTW9udGggIT09IHRhcmdldE1vbnRoIHx8XG4gICAgICAgICAgZmlsdGVyWWVhciAhPT0gdGFyZ2V0WWVhclxuICAgICAgICApIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBHVDoge1xuICAgICAgICBpZiAoY2VsbCA8PSBkYXRlKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgR0U6IHtcbiAgICAgICAgaWYgKHRhcmdldFllYXIgPCBmaWx0ZXJZZWFyKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRZZWFyID09PSBmaWx0ZXJZZWFyICYmXG4gICAgICAgICAgdGFyZ2V0TW9udGggPCBmaWx0ZXJNb250aCkge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0WWVhciA9PT0gZmlsdGVyWWVhciAmJlxuICAgICAgICAgIHRhcmdldE1vbnRoID09PSBmaWx0ZXJNb250aCAmJlxuICAgICAgICAgIHRhcmdldERhdGUgPCBmaWx0ZXJEYXRlKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgTFQ6IHtcbiAgICAgICAgaWYgKGNlbGwgPj0gZGF0ZSkge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIExFOiB7XG4gICAgICAgIGlmICh0YXJnZXRZZWFyID4gZmlsdGVyWWVhcikge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0WWVhciA9PT0gZmlsdGVyWWVhciAmJlxuICAgICAgICAgIHRhcmdldE1vbnRoID4gZmlsdGVyTW9udGgpIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFllYXIgPT09IGZpbHRlclllYXIgJiZcbiAgICAgICAgICB0YXJnZXRNb250aCA9PT0gZmlsdGVyTW9udGggJiZcbiAgICAgICAgICB0YXJnZXREYXRlID4gZmlsdGVyRGF0ZSkge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIE5FOiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBmaWx0ZXJEYXRlID09PSB0YXJnZXREYXRlICYmXG4gICAgICAgICAgZmlsdGVyTW9udGggPT09IHRhcmdldE1vbnRoICYmXG4gICAgICAgICAgZmlsdGVyWWVhciA9PT0gdGFyZ2V0WWVhclxuICAgICAgICApIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdEYXRlIGNvbXBhcmF0b3IgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJCeUFycmF5ID0gXyA9PiAoXG4gIGRhdGEsXG4gIGRhdGFGaWVsZCxcbiAgeyBmaWx0ZXJWYWwsIGNvbXBhcmF0b3IgfVxuKSA9PiB7XG4gIGlmIChmaWx0ZXJWYWwubGVuZ3RoID09PSAwKSByZXR1cm4gZGF0YTtcbiAgY29uc3QgcmVmaW5lZEZpbHRlclZhbCA9IGZpbHRlclZhbFxuICAgIC5maWx0ZXIoeCA9PiBfLmlzRGVmaW5lZCh4KSlcbiAgICAubWFwKHggPT4geC50b1N0cmluZygpKTtcbiAgcmV0dXJuIGRhdGEuZmlsdGVyKChyb3cpID0+IHtcbiAgICBjb25zdCBjZWxsID0gXy5nZXQocm93LCBkYXRhRmllbGQpO1xuICAgIGxldCBjZWxsU3RyID0gXy5pc0RlZmluZWQoY2VsbCkgPyBjZWxsLnRvU3RyaW5nKCkgOiAnJztcbiAgICBpZiAoY29tcGFyYXRvciA9PT0gRVEpIHtcbiAgICAgIHJldHVybiByZWZpbmVkRmlsdGVyVmFsLmluZGV4T2YoY2VsbFN0cikgIT09IC0xO1xuICAgIH1cbiAgICBjZWxsU3RyID0gY2VsbFN0ci50b0xvY2FsZVVwcGVyQ2FzZSgpO1xuICAgIHJldHVybiByZWZpbmVkRmlsdGVyVmFsLnNvbWUoaXRlbSA9PiBjZWxsU3RyLmluZGV4T2YoaXRlbS50b0xvY2FsZVVwcGVyQ2FzZSgpKSAhPT0gLTEpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJGYWN0b3J5ID0gXyA9PiAoZmlsdGVyVHlwZSkgPT4ge1xuICBsZXQgZmlsdGVyRm47XG4gIHN3aXRjaCAoZmlsdGVyVHlwZSkge1xuICAgIGNhc2UgRklMVEVSX1RZUEUuVEVYVDpcbiAgICBjYXNlIEZJTFRFUl9UWVBFLlNFTEVDVDpcbiAgICAgIGZpbHRlckZuID0gZmlsdGVyQnlUZXh0KF8pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGSUxURVJfVFlQRS5NVUxUSVNFTEVDVDpcbiAgICAgIGZpbHRlckZuID0gZmlsdGVyQnlBcnJheShfKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRklMVEVSX1RZUEUuTlVNQkVSOlxuICAgICAgZmlsdGVyRm4gPSBmaWx0ZXJCeU51bWJlcihfKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRklMVEVSX1RZUEUuREFURTpcbiAgICAgIGZpbHRlckZuID0gZmlsdGVyQnlEYXRlKF8pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZpbHRlckZuID0gZmlsdGVyQnlUZXh0KF8pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJGbjtcbn07XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJzID0gKHN0b3JlLCBjb2x1bW5zLCBfKSA9PiAoY3VyckZpbHRlcnMpID0+IHtcbiAgY29uc3QgZmFjdG9yeSA9IGZpbHRlckZhY3RvcnkoXyk7XG4gIGxldCByZXN1bHQgPSBzdG9yZS5nZXRBbGxEYXRhKCk7XG4gIGxldCBmaWx0ZXJGbjtcbiAgT2JqZWN0LmtleXMoY3VyckZpbHRlcnMpLmZvckVhY2goKGRhdGFGaWVsZCkgPT4ge1xuICAgIGNvbnN0IGZpbHRlck9iaiA9IGN1cnJGaWx0ZXJzW2RhdGFGaWVsZF07XG4gICAgZmlsdGVyRm4gPSBmYWN0b3J5KGZpbHRlck9iai5maWx0ZXJUeXBlKTtcbiAgICBsZXQgZmlsdGVyVmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoY29sdW1uc1tpXS5kYXRhRmllbGQgPT09IGRhdGFGaWVsZCkge1xuICAgICAgICBmaWx0ZXJWYWx1ZSA9IGNvbHVtbnNbaV0uZmlsdGVyVmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgPSBmaWx0ZXJGbihyZXN1bHQsIGRhdGFGaWVsZCwgZmlsdGVyT2JqLCBmaWx0ZXJWYWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZmlsdGVyL3NyYy9maWx0ZXIuanMiXSwic291cmNlUm9vdCI6IiJ9
//# sourceMappingURL=react-bootstrap-table2-filter.js.map